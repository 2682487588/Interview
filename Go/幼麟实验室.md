Golang高阶基础

# 一、Golang的String

## 1.UTF编码和Golang字符集



### 1.字符集

> 一个比特位要么是1要么是0，无论如何都不能得出一个字母A，我们可以将这些例如A-Z的字符对数字进行一个映射关系，比如0100 0001代表A，然后我们创建字符集，将这些映射关系收录起来，得到一个字符编号对照表，就**叫做字符集**

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/5fd6f73a435b016fb4585bc969616895.png)

![image-20220703204046836](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220703204046836.png)

### 2.ASCII字符集

> ASCII只收录了128字符，扩展字符集有256个

![image-20220703204258217](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220703204258217.png)

### 3.GB2312字符集

> ASCII不支持汉字，就有了GB2312字符集

![image-20220703204337531](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220703204337531.png)

### 4.Unicode字符集

> 以上字符集还有很多字符没有收录，我们想制作一个通用字符集，Unicode协会就是做的这些事

### 5.定长编码，变长编码

#### 5.1 定长编码

> 如果要表达出"eggo世界"，我们直接使用Unicode字符集拿到他们编号，但是拿到编号后怎么划分顺序又是一个问题，比如随便划分成了"攲"

![image-20220703204848318](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220703204848318.png)

![image-20220703205007728](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220703205007728.png)

> **解决办法**：不管这些字符的长度是多少，统一按照边界最长的来，位数不够高位补0，**字符边界问题解决了**， 
>
> **新的问题**:浪费内存，而且字符集收录的符号越多，编码跨度越大，"定长编码浪费显著"，还得想办法解决内存消耗问题

![image-20220703205416801](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220703205416801.png)

#### 5.2 变长编码

> 定长编码不行，我们就使用变长编码，**小编号少用字节，大编号多用字节**
>
> **解决方案如下**:
>
> [0,127]一字节，最高标志位为0
>
> [128,2047]二字节，最高标志位110，还有固定标志位10
>
> [2048,65535]，最高标志位1110，有两个固定标志位10

> 01100101,最高字节为0，去掉标志位，其他对应的是就是e
>
> 11100100 10111000 1001011   用1110开头，除去三个标志位，剩下部分组合，就能得到世界的"世"

![image-20220703211048530](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220703211048530.png)

### 6.UT8详解

> UTF-8是变长编码方式，可以用1~4个字节表示，
>
> 编码规则如下：
>
> 1.对于一字节，第一位为0，剩下7为用Unicode编码表示
>
> 2.对于n个字节(n>1)，第一个字节的**前n位为1**，剩下字节的 **前两位为10**

~~~cmd
U-00000000 – U-0000007F: 0xxxxxxx
U-00000080 – U-000007FF: 110xxxxx 10xxxxxx
U-00000800 – U-0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
U-00010000 – U-001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
~~~

## 2.String底层

### 1.String的构成

> 首先需要有起始地址，这样才可以找到字符串内容，但是找不到结尾，Go语言是在起始地址后面定义了**长度**(单位：字节个数)，这样既有开头也有结尾

![image-20220703222458752](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220703222458752.png)

### 2.String的修改

> 但是我们可以读取字符串的内容，但是不能修改里面的内容，因为Go认为字符串内容不可以修改，所以会把 s1:"eggo世界"放到 **只读内存段**

> 另外，字符串变量 **共享字符串底层内容**, 我们把s1把g改成o，s2也会修改,这样的影响很严重

> **如果非要修改**
>
> 1.给变量赋新的值，这个变量的存储地址就会指向心得内容， **并没有修改**原来的内容
>
> 2.或者把变量的类型转为字节切片

![image-20220703223841633](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220703223841633.png)

### 总结

> 总结：
>
> string分为两部分，一是起始地址，而是string的长度(单位:字节个数),数据类型占有16B的空间， 字符串起始地址指针8B，存在字节个数8B
>
> 1.string内容不可修改，Go认为string是不能被修改，编译器会把string分配到只读内存段
>
> 2.我们可以通过新建切片变量来接收string,进而修改里面的字符
>
> 3.string可以为空，但是不为nil



# 二、Golang的Slice

## Slice基础

### 1.数组和切片区别

> 数组定长，切片可以看做是动态数组，长度不固定，可以追加元素
>
> 我们可以直接生命未指定·大小的数组，或者make函数和new函数进行切片创建

### 2.拷贝切片的代价

~~~go
func main()  {
 param1 := make([]int, 100)
 param2 := make([]int, 100000000)
 smallSlice(param1)
 largeSlice(param2)
}

func smallSlice(params []int)  {
 // ....
}

func largeSlice(params []int)  {
 // ....
}

~~~

**拷贝切片的实际情况**

~~~go
type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
~~~

> 切片第一个字是指向切片底层数组的指针，指向切片的存储空间
>
> 第二个字段是切片的长度
>
> 第三个字段是容量

### 3.**切片深拷贝浅拷贝**

> 深浅拷贝都会复制值，区别在于复制出来的新对象和源对象在他们改变的时候，是否相互意向，
>
> 本质是：复制出来的对象和原对象是否指向同一地址
>
> Go中切片拷贝：
>
> 1.=操作符拷贝，是浅拷贝
>
> 2.:对局部变量赋值是浅拷贝
>
> 3.Go内置copy()进行拷贝是深拷贝

上述讲的只是关于切片的深拷贝和浅拷贝，如果是Go中的深浅拷贝的区别

> **Go中对值类型的拷贝都是深拷贝，对引用类型的拷贝都是浅拷贝**

### 4.零切片，空切片,nil切片

零切片

> 切片内部数组数值全都为0的佳作nil或者底层数组为nil的叫做领切片，
>
> make创建，长度,容量不为0叫做零切片

~~~go
slice := make([]int,5) // 0 0 0 0 0
slice := make([]*int,5) // nil nil nil nil nil
~~~

nil切片

> nil切片len,cap为0，和nil比较为true

~~~go
var slice []int
var slice = *new([]int)
~~~

空切片

> 长度，容量为0，但是和nil比较为false

~~~go
var slice = []int{}
var slice = make([]int, 0)
~~~

### 5.参数传递切片和切片指针

~~~go
type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
~~~

> 当切片作为参数传递，其实就算结构体传递，因为Go语言参数传递只有值传递，传递一个切片就会浅拷贝原来的切片，但是底层数组地址没有变，所以在函数内部修改切片，也会影响函数外部

~~~go
func modifySlice(s []string)  {
 s[0] = "song"
 s[1] = "Golang"
 fmt.Println("out slice: ", s)
}

func main()  {
 s := []string{"asong", "Golang梦工厂"}
 modifySlice(s)
 fmt.Println("inner slice: ", s)
}
// 运行结果
out slice:  [song Golang]
inner slice:  [song Golang]
~~~

> 不过这也有一个特例，先看一个例子：

~~~go
func appendSlice(s []string)  {
 s = append(s, "快关注！！")
 fmt.Println("out slice: ", s)
}

func main()  {
 s := []string{"asong", "Golang梦工厂"}
 appendSlice(s)
 fmt.Println("inner slice: ", s)
}
// 运行结果
out slice:  [asong Golang梦工厂 快关注！！]
inner slice:  [asong Golang梦工厂]
~~~

> 切片发生扩容，函数外切片指向新的底层数组，所以函数内外都不会影响
>
> 如果指向底层数组的指针被覆盖或者修改(重分配，append发生扩容)，此时函数内部对数据修改不再影响函数外部切片，代表的长度len,cap不会被修改

> 参数传递切片指针，如果你想修改切片元素的值，并且更改切片容量和底层数组，应该传递指针

## Slice扩容

### 1.17扩容

> 三个规则
>
> 1.newCap>2*oldCap  --> oldCap = newCap
>
> 2.oldCap<1024 ->oldCap = 2*oldCap
>
> 3.oldCap>1024 --> oldCap = oldCap +oldCap/4

> 可以看到，原来的go对于切片扩容后的容量判断有一个明显的magic number：1024，在1024之前，增长的系数是2，而1024之后则变为1.25。关于为什么会这么设计，社区的相关讨论1给出了几点理由：
> 1.如果只选择翻倍的扩容策略，那么对于较大的切片来说，现有的方法可以更好的节省内存。
> 2.如果只选择每次系数为1.25的扩容策略，那么对于较小的切片来说扩容会很低效。
> 3.之所以选择一个小于2的系数，在扩容时被释放的内存块会在下一次扩容时更容易被重新利用

### 1.18扩容



~~~go
//1.18
newcap := old.cap
doublecap := newcap + newcap
if cap > doublecap {
  newcap = cap
} else {
  const threshold = 256
  if old.cap < threshold {
    newcap = doublecap
  } else {
    // Check 0 < newcap to detect overflow
    // and prevent an infinite loop.
    for 0 < newcap && newcap < cap {
      // Transition from growing 2x for small slices
      // to growing 1.25x for large slices. This formula
      // gives a smooth-ish transition between the two.
      newcap += (newcap + 3*threshold) / 4
    }
    // Set newcap to the requested cap when
    // the newcap calculation overflowed.
    if newcap <= 0 {
      newcap = cap
    }
  }
}

~~~

![image-20220704093116371](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704093116371.png)

> 1.18 优化切片扩容策略，让底层数组大小增长更平滑，通过增加一个固定常数来减小阈值

| 原始容量 | 扩容系数 |
| -------- | -------- |
| 256      | 2.0      |
| 512      | 1.63     |
| 1024     | 1.44     |
| 2048     | 1.35     |
| 4096     | 1.30     |

### 通过Unsafe获取Slice

~~~go
func main() {
    s := make([]int, 9, 20)
    var Len = *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + uintptr(8)))
    fmt.Println(Len, len(s)) // 9 9
    var Cap = *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + uintptr(16)))
    fmt.Println(Cap, cap(s)) // 20 20
}

~~~

### 通过Unsafe获取Map

~~~go
func main() {
    mp := make(map[string]int)
    mp["qcrao"] = 100
    mp["stefno"] = 18
    count := **(**int)(unsafe.Pointer(&mp))
    fmt.Println(count, len(mp)) // 2 2
}
~~~

# 三、结构体和内存对齐

## 1.地址总线，数据总线，机器字长

> 地址总线：
>
> cpu需要从内存读取数据，需要通过地址总线把地址传到内存，内存准备好数据，输出到地址总线，交给cpu，如果地址总线只有8根， 那么地址只有8为，寻址空间为256个地址，
>
> 想使用更大的内存，就需要有更宽的地址总线，32位地址总线可以寻址4G内存
>
> 数据总线，机器字长：
>
> 每次操作1字节麻烦，就加宽数据总线，一次想操作4字节，就需要用32根数据总线，每次操作字节数就是机器字长

![image-20220704094816090](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704094816090.png)

![image-20220704094758611](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704094758611.png)

> 之前有些cpu可以支持访问任意地址，是因为做了很多处理，如果想从地址1开始取8字节数据，cpu会分两次读，第一次是0-7，第二次是8-15

![image-20220704095031785](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704095031785.png)

## 2.内存对齐

### 2.1内存对齐概念

> 内存对齐
>
> 计算机的内存空间是按照字节进行划分的，但是实际情况，在访问特定的变量需要在特定的地址进行访问，这就需要类型数据按照特定规则排序，而不是按照顺序一个一个存放，这种叫做内存对齐
>
> 粒度：cpu一次访问一块内存的大小，我们称之为粒度
>
> 32位CPU粒度：4字节，64位CPU粒度：8字节
>
> **内存对齐作用**：减少CPU访问内存次数，提高CPU读取内存效率

### 2.2 确定内存对齐方法

> 每个类型的对齐值就是对齐边界，内存对齐要求数据存储地址以及占用字节数是对齐边界的倍数
>
> 所以int32错开两字节，从4开始存

![image-20220704095729646](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704095729646.png)

![image-20220306091430885](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/e64e427dceb38503d9f416b0aaf230d0.png)

### 2.3 windows64计算int8对齐边界

> 64位平台，最大对齐边界只有8字节，int8只有一字节，可以放在任何位置，但是会浪费7字节

![image-20220704100727579](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704100727579.png)

### 2.4 windows64确定int16

> int16占两字节，可以从下面地址存

![image-20220704100831300](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704100831300.png)

> int16占2字节，如果按照1字节对齐需要读两次然后拼接，浪费性能

![image-20220704100924741](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704100924741.png)

### 2.5windows32确定int64

> 大于的情况，对齐类型大小8，需要从下图存

![image-20220704101114057](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704101114057.png)

> 两字节被占用的情况，对齐到4，就要从下图开始存，浪费更少

![](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704101140780.png)

## 3.确定结构体边界

**第一个要求:**

> 结构体中，成员内存对齐边界最大的那个，就是这个结构体的对齐边界

![image-20220704101242169](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704101242169.png)

![image-20220704101322751](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704101322751.png)

**第二个要求:**

> 结构体占用字节数需要时结构体对齐边界的倍数(结构体选成员最大对齐边界8)，不够需要扩张

> 为什么需要限制类型大小等于对齐边界的整数倍，因为不扩大到整数倍，这个结构体类型大小就是22字节，如果后面拼接元素，那么下一个元素就对齐不了

![image-20220704101605581](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704101605581.png)

![image-20220704101625585](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704101625585.png)

### 3.2 结构体内存大小

~~~go
type Student struct {
	a int8 
	b int16
}

func main() {
	var t Student
	fmt.Println(unsafe.Sizeof(t))//4
}
~~~

### 3.3 嵌套结构体

~~~go
type Student struct {
	A
	a int8
	b int8
	c int8
	d int8
}
type A struct {
	m int8
}

func main() {
	var t Student
	fmt.Println(unsafe.Sizeof(t))//输出：5
}
~~~

### 3.4 结构体内存大小

~~~go
type T struct {
	a int8
	b int8
	c int8
	d int8
	m int8
}

type B struct {
	*T
}

func main() {
	var b B
	fmt.Println(unsafe.Sizeof(b)) // 8
}

//匿名字段是指针，那么结构体的大小是指针的大小
~~~

## 4.结构体匿名字段

### 1.结构体访问匿名字段

> 当匿名字段是struct，这个struct的所有字段和方法都被隐式定义到了电气概念struct
>
> 如果被定义struct和匿名struct都有相同属性，我们访问的时候会优先访问那个(优先访问外层)

~~~go
type Human struct {
	name       string
	age        int
	weight     int
	speciality string
}
type Student struct {
	Human      // 匿名字段，那么默认Student就包含了Human的所有字段
	speciality string
}

func main() {
	// 我们初始化一个学生
	mark := Student{Human{"Mark", 25, 120, "222222222222"}, "11111111"}
	fmt.Println(mark)
	fmt.Println(mark.Human) //{Mark 25 120 222222222222}
	// 我们访问相应的字段
	fmt.Println(mark.name) //Mark

	fmt.Println(mark.speciality)       //11111111
	fmt.Println(mark.Human.speciality) //222222222222

	//修改
	mark.speciality = "3333333"

	fmt.Println(mark.speciality) //3333333
	//以上的说明：匿名字段就是这样，能够实现字段的继承；以下说明student还能访问Human这个字段作为字段名
	mark.Human = Human{"Marcus", 55, 220, "00000000000"}
}
~~~

### 2.结构体访问匿名方法

~~~go

type Human struct {
	name string
}
type Student struct {
	Human
	speciality string
}

func (s Student) demo1() {
	fmt.Println("ssssssssssssss")
}
func (h Human) demo1() {
	fmt.Println("hhhhhhhhhh")
}
func (h Human) demo2() {
	fmt.Println("-----------------")
}

func main() {
	a := Student{}

	a.demo1() //ssssssssssssss

	a.demo2()       //---------------
	a.Human.demo1() //hhhhhhhhh
}
~~~

### 3.结构体嵌套自定义类型

> 通过匿名访问和修改字段很有效，但不仅仅是struct，所有内置字段和自定义类型都可以作为匿名字段

~~~go
type Skills []string
type Student struct {
	Skills     // 匿名字段，自定义的类型string slice
	speciality string
}
func main() {
	// 初始化学生Jane
	jane := Student{Skills: []string{"111", "ds"}, speciality: "Biology"}
	fmt.Println(jane.Skills) //[111 ds]

	jane.Skills = []string{"anatomy"} 
	fmt.Println(jane.Skills)         //[anatomy]
}
~~~

### 4.结构体嵌套内置类型

~~~go
type Student struct {
	int        // 内置类型作为匿名字段
	speciality string
}

func main() {
	// 初始化学生Jane
	jane := Student{int: 4, speciality: "Biology"}
	fmt.Println(jane.int) //4

	jane.int = 8888
	fmt.Println(jane.int) //8888
}
~~~

### 5.结构体嵌套匿名指针

~~~go

type a []string
type B struct {
	a int8
	b int32
}

type A struct {
	name string
	*int
	*a 
	* B
}



func main() {
	
}


~~~

# 四、深度解密Go底层Map

![image-20220704110055758](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704110055758.png)

## 1.什么是Map

> 在计算机科学界，被称为相关数组、map、符号表或字典，是由一组<key,value>对组成的数据结构,并且相同的key只会出现一次

> **Map的数据结构有两种**
>
> 哈希查找表(HashTable), 搜索树(Search Tree)
>
> **开销**：主要是哈希函数的计算和数组常数访问时间，很多场景，哈希查找表的性能很高

Hash Table会存在**碰撞问题**， 一般有两个应对方法： *链地址法*和 *开放地址法*

> 链地址法：将bucket实现成一个链表，落在一个bucket的key都会插入这个链表
>
> 开放地址发：碰撞后，按照一定规律，在数组后面挑选空位，放置新的key

> 平衡搜索树法的**最差搜索效率是 O(logN)，**而**哈希查找表最差是 O(N)**。当然，**哈希查找表的平均查找效率是 O(1)**，如果哈希函数设计的很好，最坏的情况基本不会出现。还有一点，遍历自平衡搜索树，返回的 key 序列，一般会按照从小到大的顺序；而哈希查找表则是乱序的。

## 2.为什么使用map

从 Go 语言官方博客摘录一段话：

> One of the most useful data structures in computer science is the hash table. Many hash table implementations exist with varying properties, but in general they offer fast lookups, adds, and deletes. Go provides a built-in map type that implements a hash table.

> hash table是计算机网络的重要设计，大部分hash table都实现快速查找，添加，删除功能
>
> 为什么使用map **因为他太强大了，增删改查效率都很高**

## 3.Map底层如何实现

### 1.Map内存模型

~~~go
type hmap struct {
	count     int // 元素个数，调用len(map)返回这个值
	flags     uint8
	B         uint8  // bucket的对数log_2
	noverflow uint16 //overflow的bucket近似数
	hash0     uint32 // 计算key的哈希会传入hash函数u

	buckets    unsafe.Pointer //指向buckets数组，数组大小2^B
    //元素个数为0，就位nil
	oldbuckets unsafe.Pointer // 扩容的时候,buckets长度是oldbuckets的两倍
	nevacuate  uintptr// 扩容进度，小于此地址buckets迁移完成
	extra *mapextra // optional fields
}
~~~

> B是buckets数组长度的对数，buckets数组长度是2^B
>
> bucket存储了key和value

~~~go
type bmap struct{
    tophash [bucketCnt] uint8
}
~~~

（src/runtime/hashmap.go）

~~~go
type bmap struct{
    topbits  [8]uint8
    keys 	 [8]keytype
    values   [8]valuetype
    pad 	 uintptr
    overflow uintptr
}
~~~

> `bmap`是我们常说的"桶"，桶里面最多装8个key，这些key会落入同一个桶，是因为他们经过hash计算发现哈希结果是"一类"的，又会根据key的hash值的高8为决定key落在桶的那个位置

![image-20220704123537125](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704123537125.png)

> 当map的key和value都不是指针，并且size<128字节,会把bmap标记为不含指针，但是我们看bmap是有一个*overflow，破坏了bmap不含指针思想，这时候会把overflow移动到extra来

~~~go
type mapextra struct{
    overflow [2]*[]*bmap
    nextOverFlow *bmap
}
~~~

![image-20220704124217050](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704124217050.png)

> 上面key和key放一起，value和value放一起，好处是省略`padding`字段

### 2.创建map

~~~go
m := make(map[string]int) 
m := make(map[string]int,8)
var m map[string]int //m为nil不能添加元素，否则为panic
~~~

`makemap`函数，初始化`hmap`结构体各个字段

~~~go
func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap
~~~

> map的结构体内部包含底层的数据指针

> makemap和makeslice的区别：当map和slice作为函数参数，在函数参数内部对map操作会影响自身，而slice不会
>
> **主要原因：一个是指针(*hmap)，一个是结构体(slice)**，Go语言函数传参都是值传递，函数内部的参数会被拷贝到本地，`*hmap`经过copy过后仍然指向一个map,slice被拷贝过后会成为新的slice对原来无影响

### 3.哈希函数

> map的一个关键点在于，在程序启动会检测cpu是否支持aes,如果支持则用aes hash 否则用memhash.这是在函数 `alginit()完成`

> hash函数有加密型和非加密型：加密型用于加密数据，数字摘要，典型的：md5,sha1,sha256,aes256
>
> 非加密型：查找，map应用场景主要是查找

![image-20220704125727503](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704125727503.png)

> 其中`alg`字段就于hash相关

~~~go
type typeAlg struct{
    hash func(unsafe.Pointer, uintptr) uintptr
    equal func(unsafe.Pointer, unsafe.Pointer) bool
}
~~~

### 4.key定位过程

key经过哈希计算得到哈希值，计算他要落到那个桶里面，最后会用到B个bit位

~~~go
10010111|000011110110110010001111001010100010010110010101010│01010
~~~

> 最后的5个bit位，是`01010`，也就是10号桶
>
> 然后取哈希值的高8位，找到key在bucket中的位置，最开始桶内还没有key,新加入的key会找到第一个空位然后放入
>
> buckets编号就是桶编号，当两个不同的key落在同一个桶中，就发生了hash冲突， **解决冲突方法：链表法**

![image-20220704205610534](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704205610534.png)

> 上图B=5，则一共有2^B=32个桶，然后第五位是`00110`是6，高8位是`10010111`对应十进制151，对应2号槽位
>
> 如果bucket没找到，并且overflow不为空，需要到overflow查找

> 我们看`mapaccessl`函数

![image-20220704210207677](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704210207677.png)

key和value方法和整个循环的方法

~~~go
//key定位公式
k := add(unsafe.Pointer(b),dataOffset+i*uintptr(t.keySize))
//value定位公式
v := add(unsafe.Pointer(b),dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
~~~

![image-20220704210949343](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704210949343.png)

![image-20220704211038293](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704211038293.png)

下面几个状态代表bucket

~~~go
//空的cell 初始bucket状态
empty =0
//空的cell,表示cell已经被搬迁到bucket
evecuatedEmpty = 1
//key.value搬迁完毕  但是key在value的前半部分
evacuatedX = 2
//key在后半部分
evacuatedY = 3
//topHash的最小正常值
minTopHash = 4
~~~

> 源码判断是否搬迁完毕

~~~go
func evacuated(b *bmap) bool{
    h := b.tophash[0]
    return h>empty&& h<minTopHash
}
~~~

### 5.Map的get方法

> Go中有两种获取map语法：带comma和不带comma

~~~go
package main
import "fmt"
func main(){
    m := make(map[string]int)
    m["bwll"]= 21
    //不带comma
    age1 := m["bwll"]
    fmt.Println(age1)
    //带comma
    age2,ok := m["bwll"]
    fmp.Println(age2,ok)
}

//0
//0 false
~~~

![image-20220704211830539](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704211830539.png)

![image-20220704211841196](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704211841196.png)

### 6.扩容

> 使用哈希表是为了快速查找Key，随着map被添加，key发生碰撞概率也越来越大，bucket的8个cell会主键填满，插入，查找效率逐渐降低,  (最理想状态下，一个Bucket只存一个key，就能达到0（1）效率)
>
> 如果所有的key落在一个bucket就导致退化成了链表，各种操作变为0(n)这样不行

> 需要有一个`装载因子`

~~~go
loadFactor := count /(2^B)
~~~

> count就是元素数量，2^B是桶的数量
>
> 当向map中插入新的key，会进行条件检测

> 1.装载因子>6.5
>
> 2.overflow的bucket过多，
>
> 当B<15,如果overflow的bucket超过2^B
>
> 或者B>15,overflow的bucket超过2^15

![image-20220704213154652](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704213154652.png)

> 对于条件1，元素太多,bucket太少，将B+1，这时候就有新老bucket,但是元素都在老的bucket,没有迁移到新的Bucket,新bucket数量变为原来二倍(2^B*2)
>
> 条件2可以重新开辟一个bucket，然后把老**的bucket的key和overflow bucket的key**放到新的bucket里面
>
> **还有极端情况**，如果map的key都一样，落到同一个bucket，超过8个产生overflow bucket,移动元素解决不了问题，整个哈希表退化成了单链表，操作效率是0(n)
>
> **极端问题解决办法**： 我们需要将原有的key/value搬迁到新的内存地址，**如果需要大量key/value**搬迁，这是非常消耗性能， 所以我们使用 **渐进式扩容**

> `hasGrow`没有搬迁，只是分配号buckets,将老的bucket挂载到oldbuckets，真正搬迁是 `mapassign `和`mapdelete`,插入，修改，删除key会尝试搬迁

![image-20220704214824009](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704214824009.png)

刚开始nevacuate被置位0，显示当前搬迁进度为0

![image-20220704215031428](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704215031428.png)

![image-20220704215158874](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704215158874.png)

bucketmask就是将key计算出来与bucketmask相与，比如B=5那么bucketmask就是`11111`，只有hash值低五位决定key落在那个桶

![image-20220704215428764](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220704215428764.png)

# 六、闭包

## 1.FuncVal对象

> 闭包复制的是原对象指针，这就容易解释延时调用

> 函数可以作为参数传递，也可以作为返回值，也可以绑定到变量
>
> go称这样的函数叫做function value

![image-20220705080849837](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705080849837.png)

> 函数指令在编译期间生成，function value本质是一个指针，但是并不直接指向函数的指令入口，而是指向runtime.funcval结构体，结构体只有一个地址，就是函数指令的入口

![image-20220705081516988](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705081516988.png)

![image-20220705081754386](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705081754386.png)

![image-20220705081802235](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705081802235.png)

![image-20220705081809546](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705081809546.png)

![image-20220705081818505](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705081818505.png)

## 2.闭包在函数调用栈的变化

## 3. 闭包在函数调用栈的变化（捕获局部变量只赋值）

> 为什么需要通过funcval结构体包装地址然后通过二级指针调用，这和闭包的定义有关
>
> 1.必须有函数外部定义，但是在函数内部引用的"自由变量"
>
> 2.即使脱离了上下文，闭包也可以自由引用这些变量



![image-20220705082103567](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705082103567.png)

> 函数create的返回值是一个函数，但这个函数内使用了外部定义的变量c,
>
> 即使create函数结束，但是通过f1和f2仍然可以调用这个闭包函数，并且使用定义在局部变量内部的c，通常这个c为捕捉变量
>
> 闭包函数的指令在编译阶段生成，但是每个闭包都要保存自己的捕获变量，所以到执行阶段才创建相应的闭包对象

![image-20220705084942577](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705084942577.png)

> 然后是返回值空间

![image-20220705085444380](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705085444380.png)

> 到create函数栈帧这里，有一个局部变量值2

![image-20220705085849289](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220705085849289.png)

> create函数会在堆上分配一个funcval结构体,fn指向闭包函数入口

![image-20220705090602542](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705090602542.png)

> 除此之外，还有一个捕获列表，当前只捕获了一个变量c

![image-20220705090657067](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705090657067.png)

> 下次调用create函数，会继续创建一个funcval结构体,同样捕获变量C

![image-20220705091659475](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705091659475.png)

> 通过f1和f2进行调用闭包函数，找到对应的funcval结构体
>
> 但是f1需要调用"addr2 fn = addr1"
>
> f2调用需要使用"addr3 fn = addr1"

![image-20220705091940835](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705091940835.png)

![image-20220705091955668](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705091955668.png)

> **闭包如何找到捕获列表**,go语言中通过一个function value结构体调用函数时，会把对应的funcval结构体地址存入特定寄存器，**这样在闭包函数中，就可以通过寄存器取出funcval结构体的地址，然后加上相应的偏移来找到每一个被捕获的变量**
>
> go语言的闭包就是有捕获列表的funcval

![image-20220705092124252](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705092124252.png)

## 4.闭包捕获局部变量被初始化赋值并且修改

> 除了初始化赋值之外还被修饰过，这就需要再细分,在下面这个例子中，被捕获的是局部变量i，而且除了初始化赋值(i:=0)外还被修改(i++)过

~~~go
//返回的是一个func()函数类型的数组
func create() (fs [2]func()) {
	for i := 0; i < 2; i++ {
		fs[i] = func() {
			fmt.Println(i)
		}
	}
	return
}
func main() {
	fs := create()
	for i := 0; i < len(fs); i++ {
		fs[i]()
	}
	/*输出：
	2
	2
	*/
}
~~~

> 到create函数栈帧，由于闭包变量被捕获，局部变量i改为堆分配**，在栈上只有一个地址**！！！

![image-20220705092844357](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705092844357.png)

> 第一次for循环,在堆上创建funcval结构体，捕获i的地址，这样闭包函数就和外层函数操作同一个变量了

![image-20220705093429579](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705093429579.png)

> 返回值第一个元素存储addr0，第一次for循环结束，i自增1

![image-20220307105121332](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/bc666df63e8403c291c1cbf14ddc0876.png)

> 第二次for循环开始，再次堆分配一个funcval，捕获变量i的地址，第二个元素存储addr1，第二次循环结束，i再次自增1

![image-20220705093502917](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705093502917.png)

> 此时满足循环退出条件，create函数结束，把返回值拷贝到局部变量fs

![image-20220705093539413](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705093539413.png)

> 通过fs[0]调用函数，把addr0写入寄存器，就可以找到addr0，然后通过寄存器存储加上便宜找到捕获变量i的地址

![image-20220705093646712](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705093646712.png)

> fs[1]同理，通过f[s1]调用时，把add1存入寄存器，就可以找到addr1那个位置。闭包函数通过寄存器存储的地址加上偏移找到捕获变量i的地址.被捕获的地址都指向它，所以那里每次都会打印2

![image-20220705093708041](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705093708041.png)

> 闭包导致的局部变量堆分配，也是变量逃逸的一种场景

![image-20220705093726676](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705093726676.png)

## 5.闭包对象在函数调用栈中变化(捕获变量为参数)

> 如果有修改并被捕获的是参数，涉及到函数原型，就不能像局部变量那样处理了；
> 参数依然通过调用者栈帧传入 ，但是编译器会把栈上这个参数拷贝到堆上一份。然后外层函数和闭包函数都使用堆上分配的这一个

![image-20220705093818989](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705093818989.png)



## 6.闭包对象在函数调用栈中变化(捕获变量为返回值)

> 如果被捕获的是返回值，处理方式又有些不同；
> 调用者栈帧上依然会分配返回值的空间，不过闭包的外层函数会在堆 上也分配一个，外层函数和闭包函数都使用堆上这个，但是在外层函数返回前，需要把堆上的返回值拷贝到栈上的返回值空间，处理方式虽然比较多样，但是目标只有一个，就是保持捕获变量在外层函数与闭包函数中的一致性


![image-20220705093841733](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705093841733.png)

# 七，方法

## 1.方法定义

> func(receiver type) methodName(参数列表)(返回值列表){}
>
> 1.一个包含了接收者的函数，接受者可以使命名类型，结构体类型，指针
>
> 2.只能为当前包内命名类型定义方法
>
> 3.不支持方法重载，receiver 只是参数签名的组成部分；
>
> 4.Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)；
>
> 5.参数 receiver 可任意命名，如方法中未曾使用 ，可省略参数名；
>
> 6.参数 receiver 类型可以是 T 或 *T ;
>
> 7.参数和返回值可以省略 ；
>
> 8.可用实例 value 或 pointer 调用全部方法，编译器自动转换

~~~go
package main
type Test struct{}
// 无参数、无返回值
func (t Test) method0() {}
// 单参数、无返回值
func (t Test) method1(i int) {
}
// 多参数、无返回值
func (t Test) method2(x, y int) {
}
// 无参数、单返回值
func (t Test) method3() (i int) {
    return
}
// 多参数、多返回值
func (t Test) method4(x, y int) (z int, err error) {
    return
}
func main() {}  
~~~

## 2.值类型调用(值接收者)

~~~go
type A struct {
	name string
}

func (a A) Name() string {
	a.name = "Hi!"
	return a.name
}

func main() {
	a := A{name: "eggo"}
     //可用实例 value调用方法，编译器自动转换
    a.Name()//等效于A.Name(a)
	fmt.Println(a.name)//输出：aggo
}
//注意，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作
~~~

> a.Name()等效于A.Name(a)

> 不对结构体初始化也照常可以调用方法

~~~go
type Animal struct {
    Age int
}

func (animal Animal) getName() string {
    return "animal"  //返回一个字符串
}

func main() {
    var animal Animal
    fmt.Println(animal.getName())
    fmt.Println(person.getName())
}
~~~

## 3. 指针类型调用方法(值接收者)

~~~go
type A struct {
	name string
}

func (a A) Name() string {
	a.name = "Hi!"
	return a.name
}
func main() {
	a := A{name: "eggo"}
	b := &a
    //可用实例 pointer 调用全部方法，编译器自动转换
    b.Name()//等效于:(*b).Name()   ,A.Name(*b)
	fmt.Println(a.name) //输出：eggo
}
//注意，当接受者不是一个指针时，该方法操作对应接受者的值的副本(意思就是即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。
~~~

> 以下的方式也算指针类型调用方法(值接收者)

~~~go
type A struct {
	name string
}

func (a A) Name() string {
	a.name = "Hi!"
	return a.name
}
func main() {
	a := &A{name: "eggo"}
	a.Name()
	fmt.Println(a.name) //输出：eggo
}
~~~

## 4. 值类型调用方法(指针接受者)

~~~go
type A struct {
	name string
}
func (a *A) Name() string {
	a.name = "Hi!"
	return a.name
}
func main() {
	a := A{name: "eggo"}
    a.Name()//等效于: (&a).Name()   ,   (*A).Name(&a)
	fmt.Println(a.name) //输出：Hi
}
//注意：当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作。
~~~

> a.Name()等效于: (*A).SetName(&a)

~~~go
type A struct {
	name string
}
func (a *A) Name() string {
	a.name = "Hi!"
	return a.name
}
func main() {
	a := A{name: "eggo"}
	(*A).Name(&a)
	fmt.Println(a.name) //输出：Hi
}
~~~

## 5.指针类型调用方法(指针接收者)

~~~go
type A struct {
	name string
}

func (a *A) Name() string {
	a.name = "Hi!"
	return a.name
}

func main() {
	a := A{name: "eggo"}
	b := &a
    b.Name()//等效于:(*A).Name(b)
	fmt.Println(a.name) //输出：Hi
}
~~~

> 以下的方式也算指针类型调用方法(指针接收者)

~~~go
type A struct {
	name string
}

func (a *A) Name() string {
	a.name = "Hi!"
	return a.name
}

func main() {
	a := &A{name: "eggo"}
	a.Name()
	fmt.Println(a.name) //输出：Hi
}
~~~

## 6.调用函数(值接收者)

~~~go
//接收值类型参数的函数
func valueIntTest(a int) int {
	return a + 10
}
func main() {
	a := 2
	fmt.Println("valueIntTest:", valueIntTest(a))
	//函数的参数为值类型，则不能直接将指针作为参数传递
	//fmt.Println("valueIntTest:", valueIntTest(&a))
	//compile error: cannot use &a (type *int) as type int in function argument
}
~~~

## 7.调用函数(指针接收者)

~~~go
//接收指针类型参数的函数
func pointerIntTest(a *int) int {
    return *a + 10
}
func main() {
	 b := 5
    fmt.Println("pointerIntTest:", pointerIntTest(&b))
    //同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递
    //fmt.Println("pointerIntTest:", pointerIntTest(b))
    //compile error:cannot use b (type int) as type *int in function argument
}
~~~

## 8.不同结构体可以定义相同方法

~~~go
type Human struct {
	name string
}
type Student struct {
	speciality string
}

func (s Student) demo1() {
	fmt.Println("ssssssssssssss")
}
func (h Human) demo1() {
	fmt.Println("hhhhhhhhhh")
}

func main() {
	a := Human{}
	b := Student{}
	a.demo1()//hhhhhhhhhh
	b.demo1()//sssssssssssssss
}
~~~

## 9.函数与与方法的区别

> 普通函数与方法的区别：
> 1.对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然；
> 2.对于方法（如struct的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以

## 10.reflet.TypeOf验证方法是函数

~~~go
type A struct {
	name string
}

func (a A) Name() string {
	a.name = "Hi!" + a.name
	return a.name
}

func Name(a A) string {
	a.name = "Hi!" + a.name
	return a.name
}

func main() {
	t1 := reflect.TypeOf(A.Name)
	t2 := reflect.TypeOf(Name)
	fmt.Println(t1 == t2)//true
}
~~~

# 八、GMP调度

## 一、Hello Goroutine的执行过程



https://blog.csdn.net/weixin_52690231/article/details/123384608

https://blog.csdn.net/weixin_52690231/article/details/124347698



## 二、Go修养之路——GMP调度



### 6.Go启动M0和G0



![image-20220705152954333](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705152954333.png)

![image-20220705153338520](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705153338520.png)

#### 1.场景1

> 局部性，我们希望G1创建的Goroutine和G1在同一个线程，因为可能会公用到一些相同的自愿

![image-20220705154053334](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705154053334.png)

> 满足局部性：G3优先加入G1的队列

### 2.场景2 G1执行完毕

![image-20220705154343118](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705154343118.png)

> M1上的G1执行完毕，会优先从P的本地队列的G2执行

### 3.场景3，4，5

> P1本地队列已经满了(队列长度为4，插入G3,G4,G5,G6)
>
> 会把队列一半（G3,G4）打散然后和G7放到队列
>
> 然后G8放入队列发现队列未满就直接放入

![image-20220705154901218](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705154901218.png)

### 6. 场景6  唤醒正在休眠的线程

![image-20220705155307688](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705155307688.png)

> G2唤醒M2，M2绑定P2，并且运行G0，但是P2本地没有G，M2此时为自旋线程（没有G但是不断寻找G）

### 7. 场景7 被唤醒的M2从全局队列获取批量G

![image-20220705155558032](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705155558032.png)

> n = min(len(GQ)/GOMAXPROCS+1,len(GQ)/2)

从全局队列到本地队列的负载均衡

### 8.场景8 M2从M1偷取

![image-20220705160052815](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705160052815.png)

> 如果M2的本地队列没有了，全局队列也没有了，这时候会取M1的本地队列的后半部分，直接拿过来（有人说是前半部分？）

### 9.场景9 自旋线程的最大限制

![image-20220705160519490](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705160519490.png)

> 自旋线程+执行线程<=GOMAXPROCS

### 10. 场景10 G发送系统调用

![image-20220705161038837](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705161038837.png)

### 11.场景1 G发生系统调用/非阻塞

![image-20220705161338011](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705161338011.png)

> M2与P2解绑，但M2会记住P2，然后G8和M2进行系统调用状态，当G8和M2退出系统调用，会尝试获取P2，如果无法获取，则会获取空闲的P，如果依然没有,G8会被即为可运行状态并且加入全局队列，M2因为没有P的绑定编程休眠状态（长时间休眠会等待GC回收）

# 九、Golang三色标记混合写屏障GC

## 1.Go V1.3之前的标记-清除(mark and sweep)算法



### 1 标记清除算法的具体步骤

> 1.暂停业务，找出可达和不可达对象

![image-20220705165348211](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705165348211.png)

> 2.开始标记，找出可达对象，做上标记

![image-20220705165559757](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705165559757.png)

> 3.标记完了，开始清除未标记对象

![image-20220705165739793](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705165739793.png)

> 操作简单，mark and sweep 在需要让程序暂停 即`STW（Stop the world）`,CPU不执行代码，用于垃圾回收

> 4.停止暂停，让程序继续

## 2.标记-清扫(mark and sweep)的缺点

> STW  stop and world 让程序暂停，程序卡顿（重要问题）
>
> 标记需要扫描整个heap
>
> 清除数据产生heap碎片

![image-20220705170150086](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705170150086.png)

## 3.V1.5的三色标记法

> **第一步** 新创建对象，默认都是“白色” (将所有对象都放入白色集合)

![image-20220705192559384](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705192559384.png)

> 这些 "程序"，是这些对象根节点的集合

![image-20220705192817001](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705192817001.png)

> 第二步  每次GC都会从根节点遍历所对象，把遍历到的从白色集合 放到 “灰色”集合(注意：本次遍历是一次遍历)

![image-20220705192934653](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705192934653.png)

> 第三步，遍历灰色集合，然后将灰色对象引用的白色对象放入灰色集合，之后将灰色对象放入黑色集合（只是一次扫描，没有递归扫描）

![image-20220705193156413](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705193156413.png)

> 第四步，重复第三步，直到灰色中中无任何对象

![image-20220705193252464](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705193252464.png)

> 第五部，回收所有白色标记表的对象

![image-20220705193332135](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705193332135.png)

## 四、没有STW的三色标记法

> 如果不暂停程序，程序的逻辑改变对象的引用关系，这种如果在标记阶段发生修改，就会影响标记结果的正确性

> 如果我们没有STW，标记的过程中会发生什么事情？

![image-20220705195244352](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705195244352.png)



> 如果不启动STW，GC扫描过程中仍然可能发生读写，如果还没有扫描到2，已经被标记为黑色的4，创建了一个指针指向3，同时2将指针p移除，就会发生如下情况

![image-20220705195406747](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705195406747.png)

> 这样对象2和对象7会被标记为黑色

![image-20220705195437754](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705195437754.png)

> 到了最后一步，所有白色对象被回收

![image-20220705195539836](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705195539836.png)

> 我们发现，本来是对象4正常引用对象3，但是却被GC回收了

> 在三色标记中，有两种情况是不希望出现的
>
> **条件1**：一个白色对象被一个黑色对象引用(白色挂在黑色下)
>
> **条件2**：灰色对象与它之间可达关系的白色对象遭到破坏(**灰色丢失了白色**)
>
> 两个条件同时满足就会丢失

> 所以我们就需要两个条件去破坏这些

## 五，屏障机制

### 1.强-弱三色不变式

> 强三色不变式
>
> 不存在黑色对象引用白色对象的指针

![image-20220705200813438](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705200813438.png)

> 弱三色不变式
>
> 所有被黑色对象引用的白色对象都处于灰色保护状态

![image-20220705200851154](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705200851154.png)

> 为了遵循上述两个方式，GC演进到两个屏障方式，"插入屏障", “删除屏障”

### 2.插入屏障

> `**具体操作**`: A对象引用B对象时候，B对象被标记为灰色（B在A的下游,B必须为灰色）
>
> 满足： **强三色不等式**(不存在黑色对象引用白色对象)

> 场景：

~~~go
A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色
~~~

> 黑色对象的内存槽有两个位置  **堆和栈**，栈特点是空间非常小，但是要求响应速度很快，因为函数弹出频繁使用，所以"插入屏障"，**栈空间不使用**

![image-20220705203700912](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705203700912.png)

![image-20220705203709908](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705203709908.png)

![image-20220705203721343](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705203721343.png)

![image-20220705203739523](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705203739523.png)

![image-20220705203756371](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705203756371.png)

![image-20220705203812227](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705203812227.png)

> 如果栈不添加，三色标记扫描之后，栈上仍然可能存在白色对象被引用情况，需要对栈重新进行三色扫描， **并且为了不让对象丢失，本次标记需要扫描启动STW，直到三色标记结束**

![image-20220705204035441](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705204035441.png)

![image-20220705204324871](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705204324871.png)

![image-20220705204335579](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705204335579.png)

> 最后扫描堆和栈，扫描剩余全部，将白色节点清除，这次STW大于在10~100ms之间

![image-20220705204418447](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705204418447.png)

### 3.删除屏障

`具体操作`: 被删除的对象，如果自身为灰色或者白色，那么标记为灰色

`满足`:弱三色不等式(保护灰色对象到白色对象的路径不会断)

> 伪代码

~~~go
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
          标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色
  }

  //2
  当前下游对象slot = 新下游对象ptr
}
~~~

> 场景：

~~~go
A.添加下游对象(B, nil)   //A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)
A.添加下游对象(B, C)         //A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)
~~~

> 示例

![image-20220705210301957](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705210301957.png)

![image-20220705210428450](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705210428450.png)

![image-20220705210509072](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705210509072.png)

![image-20220705210616684](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705210616684.png)

![image-20220705210626015](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705210626015.png)

![image-20220705210640477](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705210640477.png)

![image-20220705210658422](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705210658422.png)

## 六，Go V1.8混合写屏障机制

> 插入写屏障和删除写屏障的短板
>
> - 插入写屏障：结束需要STW扫描栈，标记栈的白色对象的存货
> - 删除写屏障：回收精度低，GC开始STW扫描堆栈记录快照，过程会保护开始时刻的所有存活对象
>
> GO v1.8引入混合写屏障，避免栈的re-scan，减少STW时间

### 1.混合写屏障机制

- 1.GC将栈上的对象扫描并且标记为黑色（之后不再扫描，无需STW）
- 2.GC期间，在栈上创建的新对象，添加为黑色
- 3.被删除的对象标记为灰色
- 4.被添加的对象标记为灰色

`满足`: **弱三色不等式**

> 伪代码

~~~go
添加下游对象(当前下游对象slot, 新下游对象ptr) {
      //1 
        标记灰色(当前下游对象slot)    //只要当前下游对象被移走，就标记灰色
      //2 
      标记灰色(新下游对象ptr)
      //3
      当前下游对象slot = 新下游对象ptr
}
~~~

### 2.混合写屏障具体场景

> 混合写屏障Gc是一种屏障机制，程序执行Gc才会执行这个机制

#### **GC开始:扫描栈区，将其全部标注为黑**

![image-20220705213541222](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705213541222.png)

![image-20220705213612435](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705213612435.png)

#### 场景一：对象被一个堆对象引用，称为栈对象的下游

> 伪代码

~~~go
//前提：堆对象4->对象7 = 对象7；  //对象7 被 对象4引用
栈对象1->对象7 = 堆对象7；  //将堆对象7 挂在 栈对象1 下游
堆对象4->对象7 = null；    //对象4 删除引用 对象7
~~~

![image-20220705213909207](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705213909207.png)

![image-20220705213916623](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705213916623.png)

#### 场景二：对象被栈对象删除，成为另外一个栈的下游

> 伪代码

~~~go
new 栈对象9；
对象8->对象3 = 对象3；      //将栈对象3 挂在 栈对象9 下游
对象2->对象3 = null；      //对象2 删除引用 对象3
~~~

![image-20220705214226028](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705214226028.png)

![image-20220705214616858](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705214616858.png)

![image-20220705214635816](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705214635816.png)

![image-20220705214650612](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705214650612.png)

#### 场景三：对象被一个堆对象删除引用，成为另外一个堆对象的下游

> 伪代码

~~~go
堆对象10->堆对象7 = 堆对象7;
堆对象4->堆对象7 = null;
~~~

![image-20220705214831705](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705214831705.png)

![image-20220705214906626](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705214906626.png)

![image-20220705214913280](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705214913280.png)

#### 场景四：对象从一个栈对象删除引用，称为另外一个堆对象的下游

> 伪代码

~~~go
堆对象4->对象2 = 堆对象2;
对象1->对象2= null;
~~~

![image-20220705215237794](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705215237794.png)

![image-20220705215257715](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705215257715.png)

![image-20220705215303564](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220705215303564.png)

> Golang的混合写屏障满足`弱三色不等式`,结合了删除写和插入写屏障的有点，只要开始并发扫描goroutine各个栈，使其变黑并且一直保持，这个过程不需要STW，标记结束后，栈在扫描始终是黑色的，也无需re_scan,减少STW时间

### 七、总结

 以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。

GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。

GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通

GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。

# 十、Golang内存逃逸

## 1.什么是内存逃逸

> 在一段程序中，每一个函数都会有自己的内存区域分配自己的局部变量，返回值，这些内存会由编译器在栈中进行分配，每一个函数会分配一个栈帧，在函数运行结束后销毁，但是有些变量我们想在函数运行结束后仍然使用，就需要把这个变量分配在堆上，这种从“栈”上逃逸到“堆”上的现象叫做内存逃逸

## 2.什么是逃逸分析

> 虽然`Go`语言引入的`Gc`，`GC`机制会对堆上的对象进行管理，当某个对象不可达(没有其他对象引用他)，他将会被回收。虽然`GC`可以降低工作人员负担，但是`GC`也会给程序带来性能损耗，**当堆内存上有大量的堆内存对象，就会给`GC`很大的压力**，虽然`Go`语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，但是我们在堆上分配大量内存，仍然会对GC造成很大压力，`Go`引入了逃逸分析，就是想减少堆内存的分配，可以在栈分配的内存尽量分配在栈上

## 3.小结

> 逃逸分析就是在程序编译阶段根据代码中的数据流，对代码中哪些变量需要在栈上分配，哪些需要在对象分配的静态分析方法，堆和栈相比，堆适合分配不可预知大小的内存，但是付出代价是分配速度慢，容易产生碎片，栈分配十分快，栈分配只需要两个指令“Push”和"Release"分配和释放，而且堆分配需要先找一块适合大小的内存块分配，需要垃圾回收释放，所以逃逸分析可以更好的做内存分配

> Go语言的逃逸分析



`src/cmd/compile/internal/gc/escape.go`

- `pointers to stack objects cannot be stored in the heap`: **指向栈对象的指针不能存储在堆中**
- `pointers to a stack object cannot outlive that object`:指向栈对象的指针不能超过该对象的存活期，指针不能在栈对象销毁之后依然存活（例子：声明的函数返回并销毁了对象的栈帧，或者它在循环迭代中被重复用于逻辑上不同的变量）

> 既然逃逸分析是在编译阶段进行的，那我们就可以通过`go build -gcflga '-m -m l'`查看逃逸分析结果

## 4.逃逸分析案例

### 1.函数返回局部指针变量

~~~go
func Add(x,y int) *int {
 res := 0
 res = x + y
 return &res
}
func main()  {
 Add(1,2)
}
~~~

~~~bash
.\pointer.go:4:2: res escapes to heap:
.\pointer.go:4:2:   flow: ~r2 = &res:
.\pointer.go:4:2:     from &res (address-of) at .\pointer.go:6:9
.\pointer.go:4:2:     from return &res (return) at .\pointer.go:6:2
.\pointer.go:4:2: moved to heap: res
~~~

> 函数返回局部变量是一个指针变量，函数`Add`执行结束，对应栈帧就会销毁，但是引用返回到函数外部，如果我们外部解析地址，就会导致程序访问非法内存，所以经过编辑器分析过后将其在堆上分配

### 2.interface类型逃逸

#### 1.interface产生逃逸

```go
func main()  {
   str := "荔枝"
   fmt.Println(str)
}
```

~~~go
E:\GoStudy\src\HighBase\Escape>go build -gcflags="-m -m -l" ./pointer.go
# command-line-arguments
.\pointer.go:20:13: str escapes to heap:
.\pointer.go:20:13:   flow: {storage for ... argument} = &{storage for str}:
.\pointer.go:20:13:     from str (spill) at .\pointer.go:20:13
.\pointer.go:20:13:     from ... argument (slice-literal-element) at .\pointer.go:20:13
.\pointer.go:20:13:   flow: {heap} = {storage for ... argument}:
.\pointer.go:20:13:     from ... argument (spill) at .\pointer.go:20:13
.\pointer.go:20:13:     from fmt.Println(... argument...) (call parameter) at .\pointer.go:20:13
.\pointer.go:20:13: ... argument does not escape
.\pointer.go:20:13: str escapes to heap
~~~

> str是main的一个局部变量，传给 `fmt.Printl()`之后逃逸，因为`fmt.Println()`的入参是`interface{}`类型,如果参数为`interface{}`，那么编译期间就很难确定参数类型

#### 2.指向栈对象的指针不能在堆中

> 我们把代码改成这样

~~~go
func main()  {
   str := "苏珊"
   fmt.Println(&str)
}
~~~

~~~go
# command-line-arguments
.\pointer.go:19:2: str escapes to heap:
.\pointer.go:19:2:   flow: {storage for ... argument} = &str:
.\pointer.go:19:2:     from &str (address-of) at .\pointer.go:20:14
.\pointer.go:19:2:     from &str (interface-converted) at .\pointer.go:20:14
.\pointer.go:19:2:     from ... argument (slice-literal-element) at .\pointer.go:20:13
.\pointer.go:19:2:   flow: {heap} = {storage for ... argument}:
.\pointer.go:19:2:     from ... argument (spill) at .\pointer.go:20:13
.\pointer.go:19:2:     from fmt.Println(... argument...) (call parameter) at .\pointer.go:20:13
.\pointer.go:19:2: moved to heap: str
.\pointer.go:20:13: ... argument does not escape
~~~

> 这次str也逃逸到堆上面了，在堆上面进行分配，因为入参是interface，变量`str`的地址被以实参的方式传入`fmt.Println`被装箱到一个`interface｛｝`
>
> 装箱的形参变量要在堆上分配，但是还需要**存储一个栈上的地址**,这和之前说的第一条不符，所以str也会分配到堆上

### 3.闭包产生逃逸

~~~go
func Increase() func() int {
 n := 0
 return func() int {
  n++
  return n
 }
}

func main() {
 in := Increase()
 fmt.Println(in()) // 1
}
~~~

~~~go
E:\GoStudy\src\HighBase\Escape>go build -gcflags "-m -m -l" ./pointer.go
# command-line-arguments
.\pointer.go:27:2: Increase capturing by ref: n (addr=false assign=true width=8)
.\pointer.go:28:9: func literal escapes to heap:
.\pointer.go:28:9:   flow: ~r0 = &{storage for func literal}:
.\pointer.go:28:9:     from func literal (spill) at .\pointer.go:28:9
.\pointer.go:28:9:     from return func literal (return) at .\pointer.go:28:2
.\pointer.go:27:2: n escapes to heap:
.\pointer.go:27:2:   flow: {storage for func literal} = &n:
.\pointer.go:27:2:     from n (captured by a closure) at .\pointer.go:29:3
.\pointer.go:27:2:     from n (reference) at .\pointer.go:29:3
.\pointer.go:27:2: moved to heap: n
.\pointer.go:28:9: func literal escapes to heap
.\pointer.go:36:16: in() escapes to heap:
.\pointer.go:36:16:   flow: {storage for ... argument} = &{storage for in()}:
.\pointer.go:36:16:     from in() (spill) at .\pointer.go:36:16
.\pointer.go:36:16:     from ... argument (slice-literal-element) at .\pointer.go:36:13
.\pointer.go:36:16:   flow: {heap} = {storage for ... argument}:
.\pointer.go:36:16:     from ... argument (spill) at .\pointer.go:36:13
.\pointer.go:36:16:     from fmt.Println(... argument...) (call parameter) at .\pointer.go:36:13
.\pointer.go:36:13: ... argument does not escape
.\pointer.go:36:16: in() escapes to heap
~~~

> 因为函数是指针类型，所以匿名函数当做返回值产生逃逸，匿名函数使用外部变量`n`,这个`n`会一直存在知道`in`被销毁

### 4. 变量大小不确定及栈空间不足引发逃逸

~~~go
import (
	"math/rand"
)

func LessThan8192()  {
	nums := make([]int, 100) // = 64KB
	for i := 0; i < len(nums); i++ {
		nums[i] = rand.Int()
	}
}


func MoreThan8192(){
	nums := make([]int, 1000000) // = 64KB
	for i := 0; i < len(nums); i++ {
		nums[i] = rand.Int()
	}
}


func NonConstant() {
	number := 10
	s := make([]int, number)
	for i := 0; i < len(s); i++ {
		s[i] = i
	}
}

func main() {
	NonConstant()
	MoreThan8192()
	LessThan8192()
}
~~~

~~~bash
# command-line-arguments
.\pointer.go:43:14: make([]int, 100) does not escape
.\pointer.go:51:14: make([]int, 1000000) escapes to heap:
.\pointer.go:51:14:   flow: {heap} = &{storage for make([]int, 1000000)}:
.\pointer.go:51:14:     from make([]int, 1000000) (too large for stack) at .\pointer.go:51:14
.\pointer.go:51:14: make([]int, 1000000) escapes to heap
.\pointer.go:60:11: make([]int, number) escapes to heap:
.\pointer.go:60:11:   flow: {heap} = &{storage for make([]int, number)}:
.\pointer.go:60:11:     from make([]int, number) (non-constant size) at .\pointer.go:60:11
.\pointer.go:60:11: make([]int, number) escapes to heap
~~~

> 栈空间足够不会发生逃逸，但是变量过大，已经超过栈空间，会逃逸到堆上

## 5.总结

- 逃逸分析在编译阶段确定哪些变量可以分配在栈中，哪些变量分配在堆上
- 逃逸分析减轻了`GC`压力，提高程序的运行速度
- 栈上内存使用完毕不需要`GC`处理，堆上内存使用完毕会交给`GC`处理
- 函数传参时对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能
- 根据代码具体分析，尽量减少逃逸代码，减轻`GC`压力，提高性能



# 十一、堆内存管理

## 一、堆内存结构

### 1.堆内存结构

Go中的runtime将堆地址空间分成了一个一个arena,arena的起始地址被定为 **arenaBaseOffset**,在amd64架构，arena的大小是64MB,地址也对齐64MB，每个arena的大小8192page,每个page大小为8kb

![image-20220706164841427](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220706164841427.png)

 程序运行所需要分配的内存块有大有小，而分散的，大小不一的内存块可能降低内存使用率

![image-20220707082641919](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707082641919.png)

另外要找到大小合适的内存块代价会因为碎片化增加，为了降低内存给程序造成的影响，Go的堆分配和tmalloc内存分配类似的算法

![image-20220707082852882](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707082852882.png)

简单来讲就是，把一组预制大小规格的内存块分配成页，然后把不同规格的内存块放入空闲链表中

![image-20220707083050168](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707083050168.png)

程序申请内存规格的时候，分配器会根据请求内存大小分配一个最适合的规格，然后从对应的空闲链表挑出一块内存进行分配

Go里面 runtime包划分了67种规格，最小8字节，最大32KB

> 所以整整齐齐的arena又会按照需求划分出不同的span，每个span包含一组连续的page,并且按照特定规格分配成了等大的内存块

![image-20220707083834096](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707083834096.png)

arena,span,page和堆内存块组成了堆内存

### 2.heapArena

> 结构组成

~~~go
type heapArena struct {
  bitmap       [heapArenaBitmapBytes]byte
  spans        [pagesPerArena]*mspan
  pageInUse    [pagesPerArena / 8]uint8
  pageMarks    [pagesPerArena / 8]uint8
  pageSpecials [pagesPerArena / 8]uint8
  checkmarks   *checkmarksMap
  zeroedBase   uintptr
}
~~~

![image-20220707084531679](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707084531679.png)

> heapArena记录存储arena的元素局，里面有一群位图标记

#### 1.heapArena.bitmap

**bitmap位图**：

1.用一位标记arena中，一个指针大小的内存单元是标量还是指针

2.在用一位标记后续的空间单元是否包含指针

为了便于操作，bitmap用一个字节可以标记arena四个指针大小的空间，

低四位用于标记指针/标量，高四位用于标记扫描/终止

> arena起始处分配一个slice，slice结构包括**一个元素指针**，**一个长度，**以及**一个容量**
>
> 1.第一字节的第0位到第2位标记这三个字段是指针还是标量；
>
> 2.第4位到第6位标记三个字段是否需要继续扫描。

![image-20220707085452804](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707085452804.png)

#### 2.heapArena.pageInUse

**pageInUser**是uint8类型的数组，长度为1024，总8192位

这个位图只用于标记，每个span的第一个page

例如arena中连续三个span分别包含1，2，3个page

![image-20220707090514322](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707090514322.png)

#### 3.heapArena.pageMarks

**pageMarks**这个位图和GC标记有点欢喜，用法和pageInUse一样，指标及每个span的第一个page,GC的时候会标记那个span包含被标记的对象，GC清扫阶段会根据这个位图，释放不含标记对象的span

#### 4.heapArena.spans

**spans**是*mspan的数组，大小为8192正好对应8192个page

### 3.mspan

mspan管理span中一组连续的page,划分内存块规格记录在spanclass

![image-20220707091908699](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707091908699.png)

**spanClass是八位**,高七位标记内存块代销规格编号，runtime提供预制规格对应编号1-67，编号0空出来对应>32KB的内存，一共68种

每种规格会按照是否GC扫描进行划分，用最低位标识

1.包含指针需要GC扫描，归位scannable

2.不包含指针归位noscan

**所以一共是136种**

~~~go

type mspan struct {
  next           *mspan
  prev           *mspan
  list           *mSpanList
  startAddr      uintptr
  npages         uintptr
  manualFreeList gclinkptr
  freeindex      uintptr
  nelems         uintptr
  allocCache     uint64
  allocBits      *gcBits
  gcmarkBits     *gcBits
  sweepgen       uint32
  divMul         uint16
  baseMask       uint16
  allocCount     uint16
  spanclass      spanClass
  state          mSpanStateBox
  needzero       uint8
  divShift       uint8
  divShift2      uint8
  elemsize       uintptr
  limit          uintptr
  speciallock    mutex
  specials       *special
}
~~~

#### 1.mspan.nelems

- nelems记录被划分多了多少内存块
- freeIndex记录下个空闲内存块的索引
- mspan已经是被划分好的内存块单元,allocBits标记哪些内存块被分配了

![image-20220707092537054](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707092537054.png)

#### 2.mspan.gcmarkBits

gcmarkBits会对当前span位图进行标记，在GC标记阶段会对位图标记，一个二进制位对应span的内存块

![image-20220707092816435](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707092816435.png)

到GC清扫阶段会把旧的allocBits释放，然后把gcmarkBits用作allocBits,这样为被标记的内存块就能回收了，当然会分配一个重新清零的内存段给gcmarkBits

------

mheap有一个全局mspan管理中心，是一个长度为136的数组(前面说过mspan的全部结构有136种),**数组元素是mcentral结构，加上一个padding**

![image-20220707093533036](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707093533036.png)

### 4.mcentral

~~~go
type mcentral struct {
  spanclass spanClass
  partial   [2]spanSet
  full      [2]spanSet
}
~~~

每一种mcentral对应一个mspan，同样记录在spanClass

每种spanClass的central,会进一步记录已用尽的(full)和未用尽的(partial)

![image-20220707094330088](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707094330088.png)

> 全局mspan管理方便用各种各样的mspan，但是为了多个P的并发安全，免不了需要加锁和解锁
>
> 为了降低多个P竞争，提高并发效率，Go的P都有一个本地缓存叫做mcache

### 5.mcache

mchache有长度136的*mspan的数组，还有专门分配noscan的tiny类型

~~~go
type mcache struct {
  nextSample uintptr
  scanAlloc  uintptr
  tiny       uintptr
  tinyoffset uintptr
  tinyAllocs uintptr
  alloc      [numSpanClasses]*mspan
  stackcache [_NumStackOrders]stackfreelist
  flushGen   uint32
}
~~~

> 当需要P的时候，先从本地缓存找mspan，如果没有或者用完了，就从mcentral放一个到本地，把用完的归还到mcentral的full set中

## 二、堆内存分配mallocgc

mallocgc是负责堆分配的关键函数，runtime的make和new都依赖他

### 1.辅助GC

#### 1.辅助gc

如果我们一遍GC一遍堆内存分配，如果堆内存分配速度>GC速度，那样就不好了，所以我们每次GC可以留出多少内存分配空间是固定的

![image-20220707101832079](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707101832079.png)

不过既然执行辅助GC，也不能白折腾，我们每次GC需要扫描64KB，每次辅助GC多出来的都会当做信用储存在G中，后续执行mallocgc()只要信用卡额度用不完就不用执行辅助gc了

![image-20220707102223775](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707102223775.png)

> 还有一种发偷懒办法逃避gc

#### 2.窃取信用

后台的GC的mark worker执行扫描，会在劝酒gcController的bgScanCredit积累信用，如果信用>债务就不用执行GC了

![image-20220707102412640](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707102412640.png)

### 2.空间分配

需要根据空间大小和是否noscan来分配空间

> 伪代码

~~~go
if size <= maxSmallSize {
  if noscan && size < maxTinySize {
    // 使用tiny allocator分配
  } else {
    // 使用mcache.alloc中对应的mspan分配
  }
} else {
  // 直接根据需要的页面数，分配大的mspan
}
~~~

![image-20220707102552338](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707102552338.png)

> **maxSmallSize**是32KB，**maxTinySize**是16字节

- size<16字节而且是noscan,用tiny allocator分配
- size>32字节，无论是noscan还是scannable都用大内存分配
- 16B<size<32KB的 no scan或者size<32KB的scannable会用预制内存分配

![image-20220707102954113](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707102954113.png)

> 大于32KB需要大块分配是因为没有内置类型
>
> 小于16B分配是为了减少浪费
>
> 如果需要连续分配16次1字节的内存，每次分配时匹配预置的内存规格8字节（这是最小的了），那么每次都会浪费7字节



![image-20220707103119813](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707103119813.png)

> tiny allocator可以合并小块内存

![image-20220707103201928](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707103201928.png)

**那tiny allocator从哪里分配内存呢？**

每个P的cache有专门用于tiny allocator的内存,16字节单元大小

~~~go

type mcache struct {
  nextSample uintptr
  scanAlloc  uintptr
  tiny       uintptr
  tinyoffset uintptr  //记录alloc这段内存到哪里了
  tinyAllocs uintptr
  alloc      [numSpanClasses]*mspan
  stackcache [_NumStackOrders]stackfreelist
  flushGen   uint32
}
~~~

> 如果tiny allocator分配size大小

如果剩余的空间不够了，就从当前P的mcache中找到对应的mspan，重新拿一个16字节大小的内存块过来用

如果本地缓存中相应规格的mspan也没有空间了，就会从mcentral中拿一个新的mspan过来。分配完以后，**如果新拿来的内存块的剩余空间比旧内存块的剩余空间还大，那就用新的内存块把旧的tiny替换掉**

![image-20220707105148731](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707105148731.png)

空间分配好了，直接通过本地mcache的mcentral配合工作，内存分配好了，还需要记录哪些内存已经分配

![image-20220707105249551](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707105249551.png)

### 3.位图标记

我们已经介绍堆内存的主要位图标记，要标记一个内存块，需要先知道他的位图在哪里

#### 第一题

> 已知：一个堆内存地址p，arena区域起始地址为arenaBaseOffset，每个arena大小为heapArenaBytes。
>
> 求：p处在第几个arena中？

![image-20220707105822171](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707105822171.png)

> arena编号 = (p-arenaBaseOffset)/heapArenaBytes

#### 第二题

> 已知：amd64架构的Linux环境下，一个arena大小和对齐边界都是64M（26位），而虚拟地址空间中的线性地址有48位，那48位的线性地址可以寻址的虚拟地址空间，就是2的48次方这么大。
>
> 求：这么大空间可以划分成多少个arena？

![image-20220707110009802](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707110009802.png)

> 个数=2的48次方/2的26次方= 4M个

如果我们将heapArena地址放到数组，并且用arena编号作为索引，那么数组为32MB

> 但是在amd64架构的Windows环境下，一个arena大小只有**4M**，那么整个虚拟地址空间一共可以划分为**64M个arena**。
>
> 若是仍然采用arena编号来索引，那这个数组得有**512MB**,这就接受不了了
>
> **所以Go里面把heapArena放到二维数组**

![image-20220707110816349](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707110816349.png)

> 所以找heapArea的时候，不能直接使用arena编号，而是计算一个arenaldx，它本质上是个uint，只不过分两部分，分别作为两个维度的索引

![image-20220707111132367](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707111132367.png)

**在amd64架构的Windows环境下：**

>  arenas数组第一维有64个元素，所以arenaIdx第一维索引占6位；

> 第二维数组长度为1M，所以arenaIdx中低20位用作第二维的索引

![image-20220707111214617](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707111214617.png)

**但在amd64架构的Linux环境下：**

这个arenas数组第一维只有一个元素，第二维有4M个元素，arenaIdx的低22位都用做第二维的索引，本质上和直接用arena编号是一样的~

**现在Arena已经分配完了**，该找mspan了

#### 第三题：

> 已知：arena中每个page大小为pageSize，每个arena中有pagesPerArena个page。
>
> 求：p处在这个arena中第几个page?

> page编号= (p / pageSize) % pagesPerArena
>
> 为什么要取余pagePerArena因为不确定在哪个arena中

确定page的索引，就可以找到headArena.spans数组的mspan

![image-20220707111825272](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220707111825272.png)

### 4.收尾工作

> **1.判断如果处在GC的标记阶段就标记新分配的对象；**
>
> 2.在memory profile开启的情况下，每分配nextSample字节内存以后，就进行一次采样；
>
> 3.在分配的过程中，size可能是向上对齐过的，所以可能会变大。而dataSize保存了原来真实的size值，所以要从分配内存的goroutine的gcAssistBytes中减去因size对齐而额外多分配的大小；
>
> **4.最后检测如果达到了GC的触发条件，就发起GC。**



### 5.小结

我们了解负责分配内存的mallowgc的主要逻辑，了解了

- 1.辅助GC
- 2.三种内存分配策略
- 从内存地址定位heapArena和mspan









# 十二、mutex

## 1. 前言

互斥锁是实现并发访问共享资源的主要手段，对此Go语言提供了Mutex,对外暴露了两个方法 Lock()和 Unlock() 用于加锁和解锁

目的：掌握Mutex的集中状态 

探究Mutex重复解锁引起的Panic的原因

## 2. Mutex数据结构

```go
type Mutex struct{
    state int32
    sema uint32
}
```

- Mutex.state: 表示互斥锁的状态， 是否解锁等等
- Mutex.sema : 表示信号量， 协程阻塞等待信号量， 解锁的协程释放信号量从而唤醒等待信号量的协程

Mutex.state是**32位的整形变量**，内部实现把该变量分为4份，记录Mutex的四种状态

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_45a91868c2c9d5dc2617e9fda0e46049_r.png)

- Locked: 表示Mutex是否被锁定， 0 ：没有锁定， 1：已经被锁定
- Woken: 表示Mutex是否被唤醒 ， 0 ：没有协程唤醒， 1：已有协程唤醒，**正在加锁过程中**
- Starving: 表示Mutex是否饥饿， 0 ：没有饥饿 ，1：饥饿，协程阻塞超过1ms
- Waiter: 表示阻塞等待锁的协程个数，  协程解锁根据这个值是否需要释放信号量

协程之间实际是抢给Locket的权利，一旦能给Locket置位1，说明抢锁成功，抢抢不到就等待Mutex.sema信号量，一旦持有锁的线程解锁，等待的线程就会被唤醒

### 2.2 Mutex方法

Mutex对外提供了两个方法：

- Lock() : 加锁方法
- UnLock():  解锁方法

加锁分成功和失败：成功直接获取锁，失败则协程阻塞

## 3. 加解锁过程

### 3.1 简单加锁

只有一个协程在加锁，没有其他干扰

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_4b43555a5440890c948680aab58e982f_r.png)

加锁过程中会判断Locked是否为0，如果为0就将Locket置位1

### 3.2 加锁被阻塞

假定加锁的时候，锁已经被其他写成占用了

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_7009a47d6e8acb7e7b9c421ad1fece22_r.png)

当协程B对已经被加锁的协程基础加锁，Waiter计数器增加1，协程B被阻塞，知道Locket变为0

### 3.3 简单解锁

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_6f4885510e5659f0615f17e6a5b89d2f_r.png)

没有其他线程等待加锁，此时解锁只需把Locket位置变为0

### 3.4 解锁并唤醒协程

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_f45d385c3f7bacc272878bbfd6d48182_r.png)

协程A解锁两个不走：一是看到Locket位置为0，而是看到Waiter>0,就释放一个信号量，唤醒一个阻塞的线程，被唤醒的协程B把Locket位置换位1，协程B得到锁

## 4. 自旋过程

加锁的时候，如果Locket结果为1，说明这个锁为其他协程所持有，尝试加锁的过程不是马上阻塞，而是持续探测Locket为0，这个过程为自旋过程

自旋的过程很短，但是如果自旋的过程中发现锁已经被释放，那么协程会立即获得锁，其他被唤醒的协程也只能继续阻塞 

好处：加锁失败不需要立即转为阻塞，而是有一定的几率来获取锁，避免线程切换

### 4.1 什么是自旋

自旋对应CPU的"PAUSE"指令，CPU对该指令什么都不做相当于空转，相当于程序sleep一小段时间自旋过程中会持续探测Locket是否为0

### 4.1 自旋条件

加锁的时候自动判断是否可以自旋，无限制的自旋给CPU巨大压力

自旋必须满足以下所有条件：

- 自旋次数够小，通常为4，一般自旋四次
- CPU核数大于1，否则自旋没有意义，此时不可能有其他协程释放锁
- 协程调度机制Process > 1 ，比如高使用GOMAXPROCS（）将处理器设置为1，不能用自旋
- 协程调度机制可运行队列为空，否则延迟协程调度

### 4.2 自旋的优势

自旋的优势是更充分利用CPU，避免协程切换，因为当前申请加锁的协程拥有CPU，经过短时间的自旋获取锁，当前协程可以继续运行，不必阻塞

### 4.3 自旋的问题

如果自旋过程获取锁，那么自旋阻塞的线程无法获取锁，如果加锁的协程特别多，每次都自旋获取锁，那么阻塞的进程就很难获取锁

## 5. Mutex模式

我们前面只关注了Waite Locket , 现在我们看Starving作用

### 4.1 normal模式

默认情况，Mutex模式为Normal

该模式下，协程加锁的不成功立即转入阻塞排队，而是判断是否满足自旋的条偶见，如果满足就会自旋，尝试抢锁

### 4.2 starvation模式

自旋过程中抢到锁， 一定意味着同一时刻协程释放了锁，我们知道释放锁时如果发现有**阻塞等待的协程**，还会**释放一个信号量来唤醒一个等待协程**，被唤醒的协程得到CPU后开始运行 ，如果超过1ms的话，会将Mutex标记为”饥饿”模式，然后再阻塞

处于饥饿模式下，**不会启动自旋过程，也即一旦有协程释放了锁**，那么一定会**唤醒协程**，被唤醒的协程将会成功获取锁，同时也会把等待计数减1

## 5. Woken状态

 Woken用于加锁和解锁，同一时刻，**两个协程一个在加锁，一个在解锁**,在加锁的协程**可能在自旋过程中，此时把Woken标记为1**,不必释放信号量

## 6. 为什么重复解锁要panic

为什么Go不能实现得更健壮些，多次执行Unlock()也不要panic？

。Unlock过程分为将Locked置为0，然后判断Waiter值，如果值>0，则释放信号量。

如果多次Unlock()，那么可能每次都释放一个信号量，这样会唤醒多个协程，**多个协程唤醒后会继续在Lock()的逻辑里抢锁，势必会增加Lock()实现的复杂度**，也会引起不必要的协程切换。

## 7. 编程Tips

### 7.1 使用defer避免死锁

加锁后立即使用defer对其解锁，可以有效的避免死锁

### 7.2 加锁和解锁应该成对出现

加锁和解锁最好出现在同一个层次的代码块中，比如同一个函数。

**重复解锁会引起panic，应避免这种操作的可能性**

# 十三、rwmutex

## 1. 前言

读写互斥锁RWMutex,在某些场景可以发挥灵活的控制能力

如果程序写操作少，读操作多，如果程序一次执行写，多次读，使用Mutex，这个过程是串行的，即使N次读操作，使用Mutex, 过程是串行的，如果使用读写锁，多个读操作可以同时持有锁，并发能力将大大提升

实现读写锁需要解决如下几个问题：

1. 写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞
2. 写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞
3. 读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞
4. 读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁

## 2. 读写锁数据结构

### 2.1 类型定义

`src/sync/rwmutex.go:RWMutex`定义了读写锁数据结构

~~~go
type RWMutex struct{
    w Mutex //控制多个血锁，获得写锁要先获得该锁，如果有一个写锁在运行，那么其他写锁会阻塞
    writerSem 	uint32 //写阻塞等待信号量，最后一个读者释放锁的时候会释放这个信号量
    readerSem 	uint32 //读阻塞信号量，写锁释放的时候会释放这个信号量
    readerCount int32 //读者的人数
    readerWait  int32 //写阻塞的读者人数
}
~~~

### 2.2 接口定义

RWMutex提供了4个简单的接口提供服务

- RLock():读锁定
- RUlock():解除读锁定
- WLock():写锁定
- WUlock():解除写锁定

#### 2.2.1 Lock()实现逻辑

写锁定需要两件事：

- 获取互斥锁
- 阻塞等待所有读操作结束（如果有的话）

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_b31533f6f5d070460b2194aa486ee040_r.png)

#### 2.2.2 Unlock()实现逻辑

解除锁定需要做的两件事：

- 唤醒因读锁定被阻塞的协程
- 解除互斥锁

所以`func (rw *RWMutex)Unlock()`  接口实现流程如图所示：

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_15371303a4b9903ccf8df1a1d3d6c761_r.png)

#### 2.2.3 RLock()实现逻辑

读锁定需要的两个事情：

- 增加读计数操作，readerCount++
- 阻塞等待写操作结束

func(rw *RWMutex) RLock()

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_970f3e966f918951584d728879e613c4_r.png)

#### 2.2.4 RUnlock()实现逻辑

决出读锁定两件事：

- 减少读计数的操作,readerCount--
- 唤醒写操作进程(如果有需要)

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_0a707690c6ed961a03c503a85f679225_r.png)

## 3. 场景分析

### 3.1 写操作是如何阻止写操作的

读写锁包括一个互斥锁(Mutex)，写锁定必定先获取互斥锁，如果互斥锁被协程A获取，意味着协程B只能阻塞等待互斥锁

### 3.2 写操作是如何阻止读操作的

RWMutex.readerCount是整值型，**实际上可以支持 2^30个读者**，写锁定的时候会先减2^30的读者，这是判断为负，如果读操作来了就知道有写操作，但是读者并没有丢失，只需要加上2^30的读者就可以了

### 3.3 读操作是如何阻止写操作的

读操作会先把readerCount+1,让readerCount不为0，这样写者就判断有读者进行操作了

### 3.4 为什么写锁定不会被饿死

#### 问题提出：

在写操作等待读操作的过程，这个过程仍然可能会有读操作不断到来， 如果写操作等待所有读操作结束。

写操作到来，会把RWMutex.readerCount拷贝RWMutex.readerWait，标记排在写操作前面的读者个数，**读操作结束后，递减RWMutex.readerWait值**，当RWMutex.readerWait变为0唤醒写操作

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_4cc8b286df29eeb2d3f3809977df015c_r.png)

# 十四、WaitGroup组成

## 1.数据结构

```go
type WaitGroup struct {
    state1 [3]uint32
}
```

state1是长度为3的数组，其中包含了state和一个信号量，state实际上是两个计数器

- counter : 还未执行结束的goroutine计数器
- waiter count : 等待goroutine-group结束的goroutine数量，有多少等待者
- semaphore:信号量

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_b68f98a52c940a8c94a7c39f1f56a901_r.png)

WaitGroup对外提供了三个接口：

- Add(delta int) 将delta值将入到counter中
- Wait():waiter递增1，并且阻塞等待信号量semaphore
- Done(): counter递减1，并且按照waiter数值释放相对应次数信号量

## 2.Add(delta int)

Add做了两件事

- delta值累加到counter,因为delta的值可以为负,counter有可能变为0或负值
- counter变为0，根据waiter释放等量信号量，counter变为负值则发生panic

```go
func (wg *WaitGroup) Add(delta int) {
    statep, semap := wg.state() //获取state和semaphore地址指针

    state := atomic.AddUint64(statep, uint64(delta)<<32) //把delta左移32位累加到state，即累加到counter中
    v := int32(state >> 32) //获取counter值
    w := uint32(state)      //获取waiter值

    if v < 0 {              //经过累加后counter值变为负值，panic
        panic("sync: negative WaitGroup counter")
    }

    //经过累加后，此时，counter >= 0
    //如果counter为正，说明不需要释放信号量，直接退出
    //如果waiter为零，说明没有等待者，也不需要释放信号量，直接退出
    if v > 0 || w == 0 {
        return
    }

    //此时，counter一定等于0，而waiter一定大于0（内部维护waiter，不会出现小于0的情况），
    //先把counter置为0，再释放waiter个数的信号量
    *statep = 0
    for ; w != 0; w-- {
        runtime_Semrelease(semap, false) //释放信号量，执行一次释放一个，唤醒一个等待者
    }
}
```

## 3. Wait()

Wait方法做了两件事，一个是累加waiter,一个是阻塞信号量

```go
func (wg *WaitGroup) Wait() {
    statep, semap := wg.state() //获取state和semaphore地址指针
    for {
        state := atomic.LoadUint64(statep) //获取state值
        v := int32(state >> 32)            //获取counter值
        w := uint32(state)                 //获取waiter值
        if v == 0 {                        //如果counter值为0，说明所有goroutine都退出了，不需要待待，直接返回
            return
        }

        // 使用CAS（比较交换算法）累加waiter，累加可能会失败，失败后通过for loop下次重试
        if atomic.CompareAndSwapUint64(statep, state, state+1) {
            runtime_Semacquire(semap) //累加成功后，等待信号量唤醒自己
            return
        }
    }
}

//这里调用CAS算法保证goroutine同时调用Wait（）也可以正确累加到Wait
```

## 4. Done()

Done制作一件事，Add()可以接受负值，所以wg.Done就是wg.Add(-1)

```go
func (wg *WaitGroup) Done() {
    wg.Add(-1)
}
```

## 5. 小结

`WaitGroup`通常用于一组 “工作协程”结束的场景，内部维护着两个计算器，我们称之为 “工作协程”和“坐等协程”

- `Add(delta int)` ,增加 "工作协程"计算器，启动“新的工作协程”前调用
- `Done()` 方法用于减少工作协程计数， 每次调用递减`1`,  在`工作协程`内部临近返回的时候调用
- `Wait()` 用于"坐等协程"计数，在所有"工作协程"启动之后调用

`Done()`方法递减“工作协程”计数后，如果“工作协程”计数变成负数时，将会触发`panic`，这就要求`Add()`方法调用要早于`Done()`方法

`Add()`方法累加的“工作协程”计数要与实际需要等待的“工作协程”数量一致，否则也会`panic`

“工作协程”计数多于实际需要等待的“工作协程”数量时, "坐等协程"会无法环形而发生死锁

“工作协程”计数小于实际需要等待的“工作协程”数量时， `Done()`会在 "工作协程"计数变为负数触发` panic` 

# 十五、通道

## 通道基本使用方式

通道是Go语言中的一等公民，其操作方式比较简单和形象。如下所示，将箭头（←）作为操作符进行通道的读取和写入。本节将详细介绍通道的基本使用方式。

### 通道声明与初始化

通道声明：

~~~go
var name chan T
~~~

通道形式：

- chan T
- chan <- T
- <-chan T

不带T不限制读写，带T 的限制读写

~~~go
chan int
chan <- float
<- chan string
~~~

未初始化的chan在编译运行不会报错，但是显然不会写入或者读取任何数据

对通道进行赋值，需要make操作符

![image-20220611143223791](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220611143223791.png)



### 2.通道写入数据![image-20220611144431214](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220611144431214.png)

无缓冲通道可以读取数据的前提是，有另外一个协程在读取通道

无缓冲通道的读写应该位于不同的协程

### 3通道读取数据

读取通道有两个返回值，第二个返回值为布尔类型，返回false代表当前通道关闭

~~~go
data,ok:= <-c
~~~

### 4.通道关闭

~~~go
close(c)
~~~

### 5. 通道作为参数和返回值

通道是协程之间的交流方式， 不管是数据读取还是写入数据，都需要将代表通道的变量通过函数传递到所在协程中去



通道作为返回值一般用于创建通道的阶段，createWorker函数创建通道C

~~~go
func createWorker(id int) chan int{
    c := make(chan int)
    go worker(id,c)
    return c
}
~~~

Go中通道是 **引用类型**而不是 **值类型**，传递到其他写成的通道，实际引用了一个通道

### 6. 单方向通道

chan <- float表示只能写入浮点数

<- chan string 表示只能读取而不能写入字符串

第一个协程完成

1. ~~~go
   func checkLink(link string, c chan string) {
   	_, err := http.Get(link)
   	if err != nil {
   		fmt.Println(link, "is up!")
   		return
   	}
   	fmt.Println(link, "is up!!")
   	c <- "is up"
   }
   func main(){
       //onetowardschan
   	link := []string{
   		"http://www.baidu.com",
   		"http://www.jd.com",
   		"https://ww.taobao.com",
   	}
   
   	c := make(chan string)
   	for _, l := range link {
   		go checkLink(l, c)
   	}
   	<-c
   }
   ~~~

> main刚开始不会接受数据而阻塞,当第一个子协程完成之后,main接受了数据不会阻塞，进而就完成了进程

![image-20220611165017911](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220611165017911.png)

## 7. 循环检查网址的状态链接

```go
package main

import (
   "fmt"
   "net/http"
)

func ForChan() {
   links := []string{
      "http://www.baidu.com",
      "http://www.jd.com",
      "https://ww.taobao.com",
   }

   c := make(chan string)
   for _, link := range links {
      go checkLinks(link, c)
   }
   for {
      go checkLinks(<-c, c)
   }
}

func checkLinks(link string, c chan string) {
   _, err := http.Get(link)
   if err != nil {
      fmt.Println(link, "might be donw!")
      c <- link
      return
   }
   fmt.Println(link, "is up!!")
   c <- link
}
```

如果将

~~~go
   for {
      go checkLinks(<-c, c)
   }
~~~

写成

~~~go
	for l := range c{
		go func() {
			time.Sleep(time.Second)
			checkLinks(l, c)
		}()
	}
/*http://www.baidu.com is up!!
http://www.jd.com is up!!
https://ww.taobao.com is up!!
https://ww.taobao.com is up!!
https://ww.taobao.com is up!!
https://ww.taobao.com is up!!*/
~~~

l变量是一个固定地址，相当于一个引用，每次读到的字符串都会赋值给l，后面变量会覆盖前面变量的值

## Select多路复用

select用于多个通道和多个协程通信的情况

我们不希望因为一个通道读写陷入阻塞，select可以解决这个问题

![image-20220611174705884](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220611174705884.png)

### select随机选择

~~~go
package Chan16_3

import "fmt"

func SelctManyTimesUse() {
	c := make(chan int, 1)
	c <- 1
	select {
	case <-c:
		fmt.Println("Hello,KuGou")
	case <-c:
		fmt.Println("Hello,QQMusic")

	}
}
//Hello,KuGou
//Hello,QQMusic
//Hello,QQMusic
//Hello,QQMusic
~~~

### select堵塞与控制

为了避免阻塞，select都有default分支

 ![image-20220613144658143](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613144658143.png)

**可以通过case定时来实现定时控制**

![image-20220613144753251](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613144753251.png)

### select和nil

一个nil的通道，不论读取和读入都陷入阻塞

当select的case对nil通道操作，case分支将永远得不到执行

~~~go
package Chan16_3

import "fmt"

func SelectAndNil() {
	a := make(chan int)
	b := make(chan int)
	go func() {
		for i := 0; i < 121; i++ {
			select {
			case a <- 2:
				a = nil
			case b <- 3333:
				b = nil


			}
		}
	}()
	fmt.Println(<-a)
	fmt.Println(<-b)
}
~~~

上述协程，一旦写入管道，就将通道置位nil，导致没有机会执行case,达到交替写入a,b通道

## 通道底层原理

### 通道结构和环形队列

~~~go
typ hchan struct{
    qcount uint		    //当前使用的数量
    dataqsiz uint       //最大容纳空间
    buf unsafe.Pointer	//对于有缓冲通道需要记录缓冲区
    elemsize uint 		//每个空间占用的长度
    closed uint32		//关闭状态
    elemtype *_type     //类型元数据
    sendx uint			//当前发送位置
    recvx uint			//当前接收位置
    recvq waitq			//接收队列
    sendq waitq			//发送队列
    lock mutex			//锁
}
~~~

![image-20220613151237085](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613151237085.png)

循环到队列末尾，send会置为0，防止下一次写入0号位置

这意味着，如果通道满了，再次写入数据陷入等待，知道第0号位移出![image-20220613151925495](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613151925495.png)

### 通道初始化

通道初始化调用makechan函数

第1个代表通道类型，带二个表示通道元素大小

makechan会判断元素大小，对齐，会在内存上分配元素大小

![image-20220613153021417](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613153021417.png)

###  通道写入原理

 c< - 5 调用 chansend执行

![image-20220613153358300](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613153358300.png)



#### 有正在等待读取的协程

通道hchan的recvq存储了等待的协程

每个协程对应sudog，包含准备获取协程中的元素指针

![image-20220613153752846](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613153752846.png)

#### 缓冲区有空余

直接向缓冲区写入当前元素

![image-20220613154056141](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613154056141.png)

#### 缓冲区无空余

通道无缓冲或者当前缓冲区满了，代表sudog结构需要放入sendq链表末尾，当前协程陷入睡眠

![image-20220613154220713](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613154220713.png)

通道读取原理

![image-20220613155844020](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613155844020.png)

有正在写入的协程

直接从写入协程链表获取第1个 协程，将写入的元素写入当前协程，唤醒被阻塞的写入协程

![image-20220613160130882](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613160130882.png)

缓冲区有元素

读取缓冲区的数据，写入当前读取协程

缓冲区无元素

当前协程的sudog放入recvq链表末尾，当前协程陷入休眠状态

![image-20220613160818959](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220613160818959.png)

# 十六、channel底层实现

### 1.channel简介

> channel很出名的话“以通信手段共享内存，channel就是最佳的体现”，channel提供一种机制，可以同时执行两个并发函数，让两个函数互相传递特定类型的值进行通信

> channel有两种，一种带缓存一种不带缓存

~~~go
make(chan int)
make(chan int,10)
~~~

~~~go
c := make(chan int)
defer close(c)
go func(){
  c <- 5   // send
}()
n := <- c   // recv
~~~

### 2. channel内部结构

> chan在runtime.go中，是一个hchan结构体

~~~go
type hchan struct {
  qcount   uint          //队列中元素的个数
  dataqsiz uint          //队列的大小
  buf      unsafe.Pointer //存放数据的指针，用unsafe.Pointer，避免GC
  elemsize uint16 		//元素的大小
  closed   uint32 		//是否关闭
  elemtype *_type 		//对应的类型元数据
  sendx    uint   		//当前send队列的位置
  recvx    uint  		//当前recv队列的位置
  recvq    waitq 		//阻塞send队列的位置
  sendq    waitq  		//阻塞recv队列的位置
  lock mutex  	//锁，保证并发
}
~~~

> 可以看得出来channel是一个环形缓冲区，channel的分配是在堆上实现的，channel的同步是通过锁实现的，channel有两个队列，一个是发送队列，一个是接收队列

> waitq是一个链表，里面对g进行简单的封装

### 3.创建channel

> 代码创建channel调用的这个函数

~~~go
CALL  runtime.makechan(SB)
~~~

> makechan的实现如下所示:

~~~go
func makechan(t *chantype, size int) *hchan {
  elem := t.elem
  // 判断 元素类型的大小
  if elem.size >= 1<<16 {
    throw("makechan: invalid channel element type")
  }
  // 判断对齐限制
  if hchanSize%maxAlign != 0 || elem.align > maxAlign {
    throw("makechan: bad alignment")
  }
  // 判断 size非负 和 是否大于 maxAlloc限制
  mem, overflow := math.MulUintptr(elem.size, uintptr(size))
  if overflow || mem > maxAlloc-hchanSize || size < 0 {
    panic(plainError("makechan: size out of range"))
  }
  var c *hchan
  switch {
  case mem == 0: // 无缓冲区，即 make没设置大小
    c = (*hchan)(mallocgc(hchanSize, nil, true)) 
    c.buf = c.raceaddr()
  case elem.ptrdata == 0:  // 数据类型不包含指针
    c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
    c.buf = add(unsafe.Pointer(c), hchanSize)
  default:  // 如果包含指针
    // Elements contain pointers.
    c = new(hchan)
    c.buf = mallocgc(mem, elem, true)
  }
  c.elemsize = uint16(elem.size)
  c.elemtype = elem
  c.dataqsiz = uint(size)
  if debugChan {
    print("makechan: chan=", c, "; elemsize=", elem.size, "; dataqsiz=", size, "\n")
  }
  return c
}
~~~

> 根据上面的代码，我们可以看到，创建channel分为三种情况:
> 1.第一种缓冲区大小为0，此时只需要分配hchansize大小的内存就ok
> 2.第二种缓冲区大小不为0，且channel的类型不包含指针，此时buf为hchanSize+元素大小*元素个数的连续内存
> 3.第三种缓冲区大小不为0，且channel的类型包含指针，则不能简单的根据元素的大小去申请内存，需要通过mallocgc去分配内存

# 十七、channel的读写和阻塞

## 1.channel数据结构

channel本身是一个环形队列

~~~go
type hchan struct{
    qcount uint       //数组大小(已经存储了多少个元素)
    dataqsiz uint     //数组容量(最多存储了多少个元素)
    buf unsafe.Pointer//缓冲区地址
    elemtype *_type   //元素类型(每个元素指向的类型元数据)(Golang的内存赋值，垃圾回收需要依赖元素的类型)
    elemsize uint16	  //元素大小(每个元素的大小)
    sendx uint		  //下一次写下标位置
    recvx uint  	  //下一次读下标位置
    sendq waitq		  //写等待队列
    recvq waitq		  //读等待队列
    closed uint32     //关闭状态
    lock mutex		  //锁
    
}
~~~

> 我们通过make创建一个缓冲区大小为5，元素类型为int的channel，ch是存在于函数上的一个栈帧，指向这个hchan数据结构

![image-20220710211033619](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710211033619.png)

**对channel数据结构的分析**

> 因为channel支持协程的并发访问，所以需要一把锁(lock)保护channel，对于有缓冲的channel来说，需要知道缓冲区的位置（buf），已经存储了多少个元素(qcount),总共能存储多少个元素(dataqsiz)，每个元素的大小(elemsize)，并且Golang运行是内存赋值，垃圾回收需要依赖数据的类型，所以hchan需要有个指针，指向类型元数据，另外channel支持交替读(发送)写(接收),需要分别记录读，写下标(sendx和recvx)，另外当读和写不能立即完成，需要让当前协程在channel等待，直到满足，然后就立即惯性

![image-20220710214014982](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710214014982.png)

## 2.阻塞和非阻塞

### 2.1写阻塞

> 我们使用ch,初始状态,ch缓冲区为空，读写下标都指向0，等待队列为空

![image-20220710214750043](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710214750043.png)

> 然后g1向ch发送数据，没有协程接收数据，所以元素被存储到缓冲区，sendx往后挪

![image-20220710214837575](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710214837575.png)

> 第5个元素会放到下标为4的位置，然后sendx重新回到0，此时缓冲区已经没有位置了

![image-20220710215008763](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710215008763.png)

> 接下来发送第6个的时候，g1会进入ch等待发送队列里面，这个是sudog类型的链表，会记录哪些协程等待，等待那个channel，等待发送数据在哪

![image-20220710215106915](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710215106915.png)

> 然后g2取出1条消息，recvx进行后移,第0个位置空出

![image-20220710215205137](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710215205137.png)

> 会唤醒sendq的g1，将elem指向的元素给ch,然后缓冲区满，sendq为空

![image-20220710215501658](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710215501658.png)

> 在此过程,sendx和recvx都会从0-4然后到0，所以channel缓冲区被称为环形缓冲区

![image-20220710215603422](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710215603422.png)

> 发送数据，
>
> 不阻塞：
>
> 1.缓冲区有空闲位置
>
> 2.有协程等待接收数据就不阻塞
>
> 阻塞：1.ch为nil
>
> 2.ch没有缓冲区也没有等待接收协程
>
> 3.ch有缓冲区但是缓冲区满而且有等待接收的协程

![image-20220710215808347](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710215808347.png)

**解决放松阻塞**

> 使用select，检测ch发送数据，执行case分支，阻塞执行default分支

![image-20220710220032544](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710220032544.png)

### 2.2读阻塞

> 不阻塞：
>
> 1.缓冲区有数据
>
> 2.有等待发送的数据
>
> 阻塞：
>
> 3.ch为nil
>
> 4.ch无缓冲
>
> 5.没有协程等待发送数据

![image-20220710220531862](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710220531862.png)

**解决方法:**

> 如果无论如何都不想阻塞，同样可以采用非阻塞式写法，这样在检测到ch的recv操作不会阻塞时，就会执行case分支，如果会阻塞，就会执行default分支。

![image-20220710220851290](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710220851290.png)

## 3.多路Select

> 上面知识单个channel操作，多路select是存在更多channel分支，每个分支可以是recv和send

![image-20220710220954431](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220710220954431.png)



















## 通道读写情况

#### **写入元素**

##### 1.有正在等待的读取协程

> 直接写入等待读取的协程的通道

##### 2.缓冲区没有满

> 在缓冲区中写入当前的元素

##### 3.缓冲区无空余

> 需要放入当前senq链表末尾，然后协程休眠，等待协程被唤醒

#### 读取元素

##### 1.有正在等待写入的协程

> 直接获取等待写入协程的第一个元素，并且写入到当前等待读的通道中

##### 2.缓冲区有元素

> 直接读取写入缓冲区中的数据

##### 3.缓冲区无元素

> 将当前协程sudog结构放入recvq链表末尾，并且当前协程陷入休眠状态，等待被唤醒

### 向Channel写数据

1. 等待接收队列`recvq`不为空，说明缓冲区没数据或没有缓冲区，此时`recv`取出G
2. 缓冲区有空余，数据写入缓冲区
3. 缓冲区无空余，数据写入G，将当前G加入`sendq`,进入睡眠

![image-20220906102825567](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220906102825567.png)



### 向Channel读数据

1. 等待发送队列`sendq`不为空，且没有缓冲区，直接从`sendq`取出G，把G的数据读出，然后把G唤醒，结束读取
2. 等待发送队列`sendq`不为空，说明缓冲区满，从缓冲区首部读取数据，然后把G中数据写入缓冲区尾部，把G唤醒
3. 缓冲区有数据则读取数据
4. 当前缓冲区为空,将goroutine加入`recvq`进入睡眠











# 十八、Context基础篇

> 总结起来就是一种接口，四种实现，六个函数

context就是负责优雅的关闭goroutine

## 1.一个接口

> golang的context包定义了Context类型，**根据官方文档**，该类型被设计用在**API边界之间以及过程之间传递截止时间，取消信号和其他请求相关的数据。**
>
> Context实际是一个接口
>
> Context包是为了处理单个请求的多个goroutine之间请求域的数据，取消信号，截止时间，这些操作设计多个API调用

~~~go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
func (c *cancelCtx) Done() <-chan struct{} {
    c.mu.Lock()
    if c.done == nil {
        c.done = make(chan struct{})
    }
    d := c.done
    c.mu.Unlock()
    return d
}
func (c *cancelCtx) Err() error {
    c.mu.Lock()
    err := c.err
    c.mu.Unlock()
    return err
}


~~~

> **DeadLine**：返回ctx的截止日期，ok为false表示没有设置，达到截止时间的ctx会被自动cancel掉
>
> 如果当前ctx是可以取消的，**Done**返回一个chan来监听，否则返回nil,当ctx被Cancel掉，返回的chan也会被close掉，变成"有信号状态"
>
> 如果ctx被cancel掉，**Err**会返回执行Cancel时指定的error,否则返回nil
>
> **Value**是用来从ctx中用指定的key提取对应的value

## 2.四种实现

~~~go
type emptyCtx int
type cancelCtx struct {
    Context
    mu       sync.Mutex            // 保护其他字段
    done     chan struct{}         // 延迟创建，被第一个cancel close
    children map[canceler]struct{} // 被第一个cancel设为nil
    err      error                 // 被第一个cancel赋值（非nil）
}
type timerCtx struct {
    cancelCtx
    timer *time.Timer // 被cancelCtx.mu保护（并发保护）
    deadline time.Time
}
type valueCtx struct {
    Context
    key, val interface{}
}
~~~

> **emptyCtx**实现了Context接口，方法都是简单返回了nil,false，实际上什么也不做，BackGround和TODO返回的Context，就是这个emptyCtx
>
> **cancelCtx**是最核心的一个类型，实现了Cancel机制和同步机制，以及父子关系的关联，可以在父Context被Cancel的情况下同步到所有子Context
>
> **timerCtx**主要支持DeadLine和TimeOut，核心功能依赖cancelCtx
>
> **valueCtx**支持key ,value打包，结合内置Context，构成一个单链表节点

## 3.六个函数

> 为了方便我们使用Context实现了一组函数

~~~go
func Background() Context
func TODO() Context
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
func WithValue(parent Context, key, val interface{}) Context
~~~

### 1.Background函数

~~~go
var (
  background = new(emptyCtx)
  todo       = new(emptyCtx)
)

func Background() Context {
  return background
}
~~~

> **BackGround**函数会创建一个没有DeadLine,没有Value也不能被Cancel的emptyCtx,通常在一个请求初始化用Background()创建最顶层的根Context

~~~go
ctx := context.Background()
~~~

`ctx`是Context类型，是个非空接口，结构如下：

![image-20220708103346913](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708103346913.png)



### 2.TODO函数

~~~go
func TODO() Context {
  return todo
}
~~~

> **TODO**函数会和BackGround一样，创建一个emptyCtx，
>
> 官方文档建议本应该在外层传递的ctx，外层却没有使用的地方调用



### 3.WithCancel

~~~go
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
~~~

> **WithCancel**函数会基于传入的parent创建一个可以Cancel掉的ctx和**cancel函数**一起返回, 调用 **cancel**函数就会把这个ctx给cancel掉，基于 **ctx**创建的子孙Context也会被一并cancel掉

~~~go
func main() {
    var wg sync.WaitGroup
    ctx := context.Background()
    ctx1, cancel = context.WithCancel(ctx)

    wg.Add(1)
    go func() {
        defer wg.Done()
        tick := time.NewTicker(300 * time.Millisecond)
        for {
            select {
            case <-ctx1.Done():
                fmt.Println(ctx1.Err())
                return
            case t := <-tick.C:
                fmt.Println(t.Nanosecond())
            }
        }
    }()
    time.Sleep(time.Second)
    cancel()
    wg.Wait()
}
~~~

> 上图把 **Background()**获取的ctx封装为可以Cancel的`ctx1`

![image-20220708105106398](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708105106398.png)

通过`ctx1.Done（）`获取一个channel，然后通过监听这个channel获取`ctx1`的Cancel通知，通过`ctx.Err()`获取`ctx1`被取消写入的错误信息

### 4.WithDeadLine

~~~go
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)
~~~

> **WithDeadLine**内部创建一个可以Cancel的ctx,并且设置一个超时时间，与一个 **cancel**函数返回，如果用户没有调用 **cancel**函数，**ctx**会在超时后自动调用Cancel

> 需要设置一个截止时间，可以用WithDeadLine创建了一个timerCtx,wg等待goroutine返回，如果超过截止时间就完成任务 `defer cancel`会把 `ctx2`返回

~~~go

func main() {
    var wg sync.WaitGroup
    ctx := context.Background()
    ctx2, cancel := context.WithDeadline(ctx,time.Now().Add(time.Second))
    defer cancel()

    wg.Add(1)
    go func() {
        defer wg.Done()
        tick := time.NewTicker(300 * time.Millisecond)
        for {
            select {
            case <-ctx2.Done():
                fmt.Println(ctx2.Err())
                return
            case t := <-tick.C:
                fmt.Println(t.Nanosecond())
            }
        }
    }()
    wg.Wait()
}
~~~

> 示例传递给WithDeadLine函数，是没有时间按且不能截止的Context
>
> WithDeadLie会基于`ctx`构建一个`cancelCtx`, `ctx2`动态类型是`*timerCtx`

![image-20220708110858622](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708110858622.png)

如果WithDeadLine接受一个有截止时间的Context，就要比较一下二者截止时间了

~~~go
ctx3, cancel := context.WithDeadline(ctx2, time.Now().Add(time.Second*2))
~~~

如果`ctx3`截止时间早于`ctx2`，就会构建一个`timeCtx`,  `timeCtx.cancelCtx`基于`ctx2`构建

![image-20220708111406090](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708111406090.png)

> 如果`ctx3`设定晚于`ctx2`，就没必要给他加定时器和截止时间。
>
> 只会用WithCancel函数基于`ctx2`构建一个cancelCtx，所以`ctx3`动态类型是`*cancelCtx`

![image-20220708111618416](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708111618416.png)

> 上面 `ctx3`是基于`ctx2`创建的, `ctx2`是基于`ctx`创建的，这样包装的结构是，这些 `Context`会形成树层结构，每个节点都可能有0或多个子节点

![image-20220708111731671](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708111731671.png)



> 对于可以取消的 Context, 实现了 `context,canceler`接口来说，他们会被注册到距离Context最近的，可以取消的祖先节点，位置在 cancelCtx结构体的 `children map`，而 *cancelCtx和 *timeCtx都实现了`canceler`接口，`ctx3`和`ctx2`

![image-20220708111941391](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708111941391.png)

> 如果`ctx2`先取消，就可以根据`children map`，取消所有子节点的Cancel的Context

![image-20220708112153038](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708112153038.png)

### 5.WithTimeout

~~~go
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
    return WithDeadline(parent, time.Now().Add(timeout))
}
~~~

`WithTime`只是`WithDeadLine`的一个wrapper，接收一个`time.Duration`类型的参数，使用当前时间加上这个时间段设置DeadLine

### 6.WithValue

~~~go

func WithValue(parent Context, key, val interface{}) Context {
    if key == nil {
        panic("nil key")
    }
    if !reflect.TypeOf(key).Comparable() {
        panic("key is not comparable")
    }
    return &valueCtx{parent, key, val}
}
~~~

> WithValue中将`parent`和传入的`key`,`val`打包成新的`ctx`，
>
> 借助valueCtx的value方法就可以后去传递数据了

> ps:

- Context本着不可改变的模式设计，不要试图修改Context里面的数据
- 为了避免后续包装的键值覆盖之前的值，最好不要用string,int类型而是通过自定义类型包装一下

> 我们举个例子来测试上述第二点

~~~go
package main
import (
    "context"
    "fmt"
)

var keyA string = "keyA"
var keyC string = "keyA"

func main() {
    ctx := context.Background()  
    ctx1 := context.WithValue(ctx, keyA, "valueA")
    fmt.Println("In ctx:")
    fmt.Println("keyA => ", ctx1.Value(keyA))

    ctx2 := context.WithValue(ctx1, keyC, "valueC")
    fmt.Println("In ctx2:")
    fmt.Println("keyA => ", ctx2.Value(keyA))
    fmt.Println("keyC => ", ctx2.Value(keyC))    
    return
}
~~~

> 运行结果如下ctx2使用相同的key覆盖ctx1中的值

~~~go

In ctx:
keyA =>  valueA
In ctx2:
keyA =>  valueC
keyC =>  valueC
~~~

我们先看`ctx1`和`ctx2`的结构，`valueCtx`的key和val都是interface{}类型，空接口类型的结构 **动态类型元数据指针**，外加一个动态值的unsafe.Pointer

 ![image-20220708143422438](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708143422438.png)

![image-20220708143427995](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708143427995.png)

结合valueCtx.Value

~~~go
func (c *valueCtx) Value(key interface{}) interface{} {
    if c.key == key {
        return c.val
    }
    return c.Context.Value(key)
}
~~~

> 当context找不到key会向父节点查找，如果查询不到最终返回interface{},通过子context查询到父value

> 可以看到，通过`ctx2.Value("keyA")`,通过比较`key`，会锁定`ctx2`中的`val`，发生了Context的Value覆盖

~~~go
type akeytype string
type ckeytype string
var keyA akeytype = "keyA"
var keyC ckeytype = "keyA"
......
~~~

> 通过`ctx2.Value(keyA)`查找Val，因为`ctx2`存储的`key`和`keyA`类型不符合，会通过请求委托查找到`ctx2`的parent，也就是ctx1，一级一级查找形成链表结构

![image-20220708144817783](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220708144817783.png)

> `WithCancel`,`WithDeadLine`和`WithValue`函数，内容是构造了`cancelCtx`，`timerCtx`,`valueCtx`这几种结构，形成一棵树

## golang中Context到底是干什么的

### 1.上下文context

> context.Context在golang中设置截止日期，同步信号，传递请求相关值的结构体
>
> 上下文和goroutine有较为密切的关系是go的独有设计

> goroutine形成树型结构对信号同步减少计算资源的浪费是context的最大作用
>
> go中的请求都是通过goroutine处理的，http/rpc请求的处理器会启动新的goroutine访问数据库和其他服务
>
> **我们可以创建多个goroutine处理一个请求**,context.Context就是在不同的goroutine之间同步请求特定数据，取消信号和处理请求截止日期
>
> 每个context.Context都可以从顶层goroutine一层一层向下传递，context.Context可以在上层goroutine执行错误，将信号同步给下层

### 2.context同步信号

~~~go
package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	// 带1s超时的context
	// 指明了我们只有一秒的时间处理handle这个协程
	ctx, cancelFunc := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancelFunc()

	go handle(ctx, 2000*time.Millisecond)

	// main协程监听超时
	select {
	case <-ctx.Done():
		fmt.Println("main", ctx.Err())
	}
}

func handle(ctx context.Context, duration time.Duration) {
	// handle协程监听超时或任务完成--duration时间处理任务
	select {
	case <-ctx.Done():
		fmt.Println("handle hhhhhhh", ctx.Err())
	case <-time.After(duration):
		fmt.Println("process request with ", duration)
	}
}
~~~

> 时间为500ms,这个时间不会超时，打印出来的数据如下

~~~go
process request with  100ms
main context deadline exceeded
~~~

> 如果时间为2000ms，因为ctx是main线程检测，所以超时的时候ctx1会被main进行中断，打印结果如下

~~~go
handle hhhhhhh context deadline exceeded
main context deadline exceeded
~~~

### **3. 默认上下文**

context包中最常用的方法还是context.Background和context.TODO，这两个方法都会返回预先初始化好的私有变量background和todo，他们会在一个go程序中被复用。

从源代码来看，context.Background和context.TODO只是互为别名，没有太大差别，只是在使用和语义上稍有不同：

- context.Background是上下文的默认值，所有其他上下文都应该从他衍生而来
- context.TODO应该仅在不确定该使用哪种上下文时使用

在多数情况下，如果当前函数没有上下文作为入参，我们都会使用context.Background作为起始的上下文传递

### 4.WithCancel

context.WithCancel函数能够从context.Context中衍生出一个新的子上下文并用于取消该上下文的函数。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的goroutine都会收到这一取消信号。

我们直接从context.WithCancel函数的实现看看它做了什么：

- context.newCancelCtx将传入的上下文包装成私有结构体context.cancelCtx
- context.propagateCancel会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消

```go
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	c := newCancelCtx(parent)
	propagateCancel(parent, &c)
	return &c, func() { c.cancel(true, Canceled) }
}
```

 

```go
func propagateCancel(parent Context, child canceler) {
	done := parent.Done()
	if done == nil {
		return // 父上下文不会触发取消信号
	}
	select {
	case <-done:
		child.cancel(false, parent.Err()) // 父上下文已经被取消
		return
	default:
	}
 
	if p, ok := parentCancelCtx(parent); ok {
		p.mu.Lock()
		if p.err != nil {
			child.cancel(false, p.err)
		} else {
			p.children[child] = struct{}{}
		}
		p.mu.Unlock()
	} else {
		go func() {
			select {
			case <-parent.Done():
				child.cancel(false, parent.Err())
			case <-child.Done():
			}
		}()
	}
}
```

　　

上述函数包含了与父上下文相关的三种不同情况：

- 当parent.Done() == nil，也就是parent不会触发取消事件时，当前函数会直接返回
- 当child的继承链包含可以取消的上下文时，会判断parent是否已经触发了取消信号。如果已经被取消，child会立即被取消；如果被有被取消，child会加入到parent的children列表中，等待parent的取消信号
- 当parent上下文是开发者自定义的类型，实现了Context接口并在Done()方法中返回了非空的管道时，运行一个新的goroutine同时监听parent.Done()和child.Done()两个chan，在parent.Done()关闭时调用child.cancel取消上下文

> context.propagateCancel的作用是在parent和child之间同步取消和结束的信号，保证在parent被取消时，child也会收到对应的信号，不会出现状态不一致的情况

# 十九 Defer

## Defer的几种特性

1. defer可以将某个方法或者语句推迟到函数返回之前执行，使用defer可以修改函数返回值(函数头部命名了返回值)
2. defer函数的注册是在函数执行到defer的时候就进行注册的，但defer的执行一般在return函数更新要return的变量之后，执行ret之前
3. defer函数一定会执行，即使发生panic,一般是在函数返回前，但是遇到panic会在panic之前执行
4. 有多个return返回相同语句，可以考虑用defer进行替代
5. 存在多个defer注册，执行顺序是先注册的后执行(类似于栈)

## Panic的几种特性

1. Go语言的panic会引起程序崩溃，一般使用Go语言提供的错误机制，而不是panic
2. 可以使用panic()进行panic的手动触发
3. panic程序中断的时候，会立即执行goroutine中的所有延迟函数(defer)，最后程序崩溃，输出错误信息

## Recover的几种特性

1. Go提供了内置的Recover函数，一般在defer中调用，返回panic value
2. 导致Panic异常的函数不会继续运行，但是可以正常返回，recover()修复panic之后，函数可以正常往下执行
3. recover进行panic的捕获的时候，defer必须在panic之前声明，否则panic，recover无法捕获panic
4. 如果Panic被recover捕获会先执行正常流程,defer函数还是会在return之前执行而不是在panic执行



**Context**

Golang context是Golang应用开发常用的并发控制技术，和WaitGroup不同的是Context对派生的goroutine有更强的控制力

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_fbdcf78fa8ee5b280dae750ff631c3d6_r.png)

# 二十、 Context实现原理

## 2.1 接口定义

源码包中 `src/context/context.go:Context`

~~~go
type Context interface{
    Deadline()(deadline time.Time, ok bool)
    Done() <-chan struct(){}
    
    Err() error
    Value(key interface{}) interface{}
}
~~~

### 2.1.1 Deadline()

返回一个deadline和标识是否设置deadline的bool值，**没有设置deadline的值，ok== false,deadline作为一个初始化的time.Time值**

### 2.1.2 Done()

该方法返回一个channel需要在select-case使用  "case <- context.Done()"

当context**关闭后**，Done()返回一个被关闭的通道，这时候的关闭的管道是可以读的,**goroutine可以收到关闭请求**

**当context未关闭，Done()返回一个nil**

### 2.1.3Err()

描述context关闭的原因，

- 因为deadline关闭, "context deadline exceeded"
- 主动关闭 "context conceled"

### 2.1.4 	Value()

有一种context,用于树状分数goroutine之间传递信息

## 2.2 空context

context包定义一个空的context，为emptyCtx,简单实现了Context，**本身不包括任何值，仅用于其他context的父节点**

空的context代码定义如下

~~~go
type emptyCtx int

func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
    return
}

func (*emptyCtx) Done() <-chan struct{} {
    return nil
}

func (*emptyCtx) Err() error {
    return nil
}

func (*emptyCtx) Value(key interface{}) interface{} {
    return nil
}
~~~

context包定义一个emptyCtx的全局变量，交background，可以用context.Background获取

~~~go
var background = new(emptyCtx)
func Background() Context {
    return background
}
~~~

![img](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/m_f41adc85deafd7243fc1eb3e6c553ced_r.png)



## 2.3 cancelCtx

源码包 `src/context/context.go:cancelCtx`定义了该类型的context

~~~go
type cancelCtx struct{
    Context
    mu sync.Mutex
    done chan struct{}
    children map[canceler]struct{}
    err error
}
~~~

**children 记录了这个context派生的所有child,此context被cancel会把所有child都cancel**

cancel和Deadline和Value无关 只需把Done()和Err()外露接口

### 2.3.1 Done()接口实现

~~~go
func (c *cancelCtx) Done() <-chan struct{} {
	d := c.done.Load()
	if d != nil {
		return d.(chan struct{})
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	d = c.done.Load()
	if d == nil {
		d = make(chan struct{})
		c.done.Store(d)
	}
	return d.(chan struct{})
}
~~~

> cancelCtx没有初始化函数，所以cancel.Done可能未分配
>
> 分配过程:nil -> chan struct{}  -> closed chan

### 2.3.2 Err()接口实现

~~~go
func (c *cancelCtx) Err() error {
    c.mu.Lock()
    err := c.err
    c.mu.Unlock()
    return err
}
~~~

> cancelCtx.err 默认是nil ,在Context被cancel返回一个变量
>
> var Canceled = errors.New("Context canceled")

### 2.3.3 Cancel()接口实现

~~~go
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
	if err == nil {
		panic("context: internal error: missing cancel error")
	}
	c.mu.Lock()
	if c.err != nil {
		c.mu.Unlock()
		return // already canceled  已经取消
	}
	c.err = err		//设置err说明关闭原因
	d, _ := c.done.Load().(chan struct{})
	if d == nil {
		c.done.Store(closedchan)
	} else {
		close(d)
	}
	for child := range c.children {
		// NOTE: acquiring the child's lock while holding parent's lock.  遍历所有children逐个cancel
		child.cancel(false, err)
	}
	c.children = nil
	c.mu.Unlock()

	if removeFromParent {	//需要将自己从parent删除
		removeChild(c.Context, c)
	}
}
~~~

WithCancel() 返回的第二个用于cancel context 正是这个concel

### 2.3.4 WithCancel()方法实现

~~~go
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	if parent == nil {
		panic("cannot create context from nil parent")
	}
	c := newCancelCtx(parent)
	propagateCancel(parent, &c)  //将自身加入父节点
	return &c, func() { c.cancel(true, Canceled) }
}
~~~

自身加入父节点

1.父节点支持cancel，父节点肯定有children成员，将新context加入children

2.父节点不支持cancel，继续查询找到一个支持cancel,将新context加入children

3.所有父节点不支持cancel，启动一个协程等待父节点结束，然后把当前context结束

### 2.3.5 典型使用案例

```go
package main

import (
    "fmt"
    "time"
    "context"
)

func HandelRequest(ctx context.Context) {
    go WriteRedis(ctx)
    go WriteDatabase(ctx)
    for {
        select {
        case <-ctx.Done():
            fmt.Println("HandelRequest Done.")
            return
        default:
            fmt.Println("HandelRequest running")
            time.Sleep(2 * time.Second)
        }
    }
}

func WriteRedis(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("WriteRedis Done.")
            return
        default:
            fmt.Println("WriteRedis running")
            time.Sleep(2 * time.Second)
        }
    }
}

func WriteDatabase(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("WriteDatabase Done.")
            return
        default:
            fmt.Println("WriteDatabase running")
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go HandelRequest(ctx)

    time.Sleep(5 * time.Second)
    fmt.Println("It's time to stop all sub goroutines!")
    cancel()

    //Just for test whether sub goroutines exit or not
    time.Sleep(5 * time.Second)
}
```

```bash
HandelRequest running
WriteDatabase running
WriteRedis running
HandelRequest running
WriteDatabase running
WriteRedis running
HandelRequest running
WriteDatabase running
WriteRedis running
It's time to stop all sub goroutines!
WriteDatabase Done.
HandelRequest Done.
WriteRedis Done.
```

## 2.4 timerCtx

```go
type timerCtx struct {
    cancelCtx
    timer *time.Timer // Under cancelCtx.mu.

    deadline time.Time
}
```

- deadline: 指定最后期限，比如context将2018.10.20 00:00:00之时自动结束
- timeout: 指定最长存活时间，比如context将在30s后结束。

### 2.4.1 Deadline()接口实现

Deadline()方法仅仅是返回**timerCtx.deadline而矣**。而timerCtx.deadline是WithDeadline()或WithTimeout()方法设置的

### 2.4.2 cancel()接口实现

cancel()方法基本继承cancelCtx，只需额外把timer关闭

- 如果deadline到来之前手动关闭，则关闭原因与cancelCtx显示一致；
- 如果deadline到来时自动关闭，则原因为：”context deadline exceeded”

### 2.4.3 WithDeadline()方法实现

- 初始化一个timeCtx实例
- 将timerCtx添加父节点的children
- 启动定时器，定时器到期会自动cancel本context
- 返回timerCtx实例和cancel()方法

### 2.4.4 WithTimeout()方法实现

WithTimeOut()调用了WithDeadLine，实际原理一样

~~~go
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
    return WithDeadline(parent, time.Now().Add(timeout))
}
~~~

### 2.4.5 典型案例

```bash
HandelRequest running
WriteRedis running
WriteDatabase running
HandelRequest running
WriteRedis running
WriteDatabase running
HandelRequest running
WriteRedis running
WriteDatabase running
HandelRequest Done.
WriteDatabase Done.
WriteRedis Done.
```

## 2.5 valueCtx

源码包中`src/context/context.go:valueCtx`：定义了类型context

```go
type valueCtx struct {
    Context
    key, val interface{}
}
```

### 2.5.1 Value()接口的实现

~~~go
func (c *valueCtx) Value(key interface{}) interface{} {
	if c.key == key {
		return c.val
	}
	return c.Context.Value(key)
}
~~~

### 2.5.2 WithValue（）方法实现

```go
func WithValue(parent Context, key, val interface{}) Context {
    if key == nil {
        panic("nil key")
    }
    return &valueCtx{parent, key, val}
}
```

### 2.5.3 典型使用案例

```go
package main

import (
    "fmt"
    "time"
    "context"
)

func HandelRequest(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("HandelRequest Done.")
            return
        default:
            fmt.Println("HandelRequest running, parameter: ", ctx.Value("parameter"))
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx := context.WithValue(context.Background(), "parameter", "1")
    go HandelRequest(ctx)

    time.Sleep(10 * time.Second)
}
```

- Context仅仅是一个接口定义，根据实现的不同，可以衍生出不同的context类型；
- cancelCtx实现了Context接口，通过WithCancel()创建cancelCtx实例；
- timerCtx实现了Context接口，通过WithDeadline()和WithTimeout()创建timerCtx实例；
- valueCtx实现了Context接口，通过WithValue()创建valueCtx实例；
- 三种context实例可互为父节点，从而可以组合成不同的应用形式；
