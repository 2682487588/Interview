# 计算机常见知识点&面试题

## 应用层常见协议

### **超文本传输协议(HTTP)**:

主要是为了Web浏览器和Web服务器之间的通信，我们使用Web浏览器浏览网页就是用HTTP协议

![img](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/450px-HTTP-Header.png)

HTTP协议是基于TCP协议，发送HTTP请求之前需要建立TCP三次握手，目前用的最多的协议是1.1，在HTTP1.1中，加入了Keep—Alive 意味着建立的连接可以被多次复用

HTTP是无状态的协议，我们如果记录状态一般是用Session来记录客户端的状态

### SMTP:简单邮件传输(发送)协议

Simple Mail Transfer Protocol 基于TCP协议，用来发送电子邮件

**PS：接收邮件的不是SMTP协议而是POP3协议**

#### 电子邮件发送过程： 

我"a2682487588@163.com"想要发送"2682487588@qq.com"一封邮件

1.通过SMTP协议，将我写好的邮件发送到163邮箱(邮局)

2.163邮局发现要发送的目的地是QQ邮箱，就将信件通过SMTP协议发送到QQ邮箱服务器

3.QQ邮箱服务器接收之后就通知，就通知"2682487588@qq.com"这个用户接收邮件，然后这个用户就通过POP3协议接收邮箱

#### 如何判断邮箱是真正存在的

很多场景需要我们判断邮箱是否存在，我们可以通过SMTP协议来判断电子邮箱是否存在

1.查找域名对应的SMTP服务器地址

2.尝试与服务器建立连接

3.连接成功后向需要验证的邮箱发送邮件

4.根据返回结果判断电子邮箱是否存在

### POP3/IMAP邮箱接收协议

SMTP协议负责邮箱的发送，真正负责接收的协议是POP3/IMAP协议

### FTP文件传输协议

**FTP协议**主要提供文件传输服务，基于TCP可靠的传输，使用**FTP的好处是可以屏蔽操作系统和文件存储方式**

FTP是基于 客户——服务器(C/S)的链接，在客户端和FTP服务器之间建立两个连接

#### FTP原理

> FTP的优势就是在两个通信的主机之间使用了两条TCP连接
>
> 1.控制连接：用于传送控制信息(命令和相应)
>
> 2.数据连接：用于传输数据

![FTP工作过程](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/ftp.png)

### Telnet：远程登录协议

**Telnet协议**通过一个终端登录到其他服务器上，建立在可靠的TCP连接上，但是缺点是所有数据(包括账号名和密码)都以明文的形式发送，这就是Telnet被SSH协议取代的原因

### SSH: 安全的网络传输协议

SSH（Secure Shell）是目前较为可靠，专为远程登录会话和其他网络服务提供安全性的协议，利用SSH可以有效防止远程管理中信息泄露问题，SSH建立在可靠的传输协议TCP之上

**Telnet和SSH的区别在于，SSH会对传输的数据进行加密处理**

## 在浏览器中输入 url 地址 ->> 显示主页的过程(面试常客)

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg)



### 从输入URL到页面加载

1.DNS解析

2.TCP连接

3.HTTP请求

4.服务器接收请求并且返回HTTP报文

5.浏览器解析渲染页面

6.连接结束

### 1.DNS解析

DNS解析就是寻找那台机器上有你资源的过程。输入www.baidu.com这个网址并不是真正地址，而是出于对ip地址难以记住进而转为让用户记住地址的 "权衡",这个权衡是从网址到IP地址的转换

![preview](https://segmentfault.com/img/bVDM45/view?w=1928&h=1248)

上面是找www.google.com的IP地址的过程。首先在本地域名服务器查询，如果没有找到的情况下，

本地域名服务器->根域名服务器->google域名服务器

com -> google.com -> www.google.com.

#### DNS优化

使用DNS缓存进行DNS的优化，DNS存在多级缓存， 离浏览器距离排序

- 浏览器缓存
- 系统缓存
- 路由器缓存
- IPS服务器缓存
- 根域名服务器缓存
- 顶级域名服务器缓存
- 主域名服务器缓存

#### DNS解析过程

- 1.y

### 2.TCP链接

HTTP协议是使用TCP作为传输层协议的，TCP出现瓶颈的时候HTTP也会受影响

### 3.HTTP请求

分为三部分： 请求航，请求，请求正文

#### 请求行

~~~shell
eg: GET index.html HTTP/1.1
~~~

#### 请求报头

请求报头允许客户端向服务器传递请求的附件信息和客户端自身的信息

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Type
- Authorization
- Cookie 
- User-Agent

![preview](https://segmentfault.com/img/bVC1BZ/view?w=1919&h=822.png)

#### 请求正文

使用POST,PUT，需要客户端向服务端传递数据，这些数据存储在正文，Web一般采用Rest架构，请求格式为json 这时候就需要： **Content-Type:application/json**

### 4.服务器处理请求并且返回HTTP报文

HTTP响应报文也是由三部分组成： **状态码**  **响应报头**  **响应报文**

- 1xx: 请求已经被接收处理
- 2xx:请求被接收，理解，接收
- 3xx:重定向 ——要完成请求必须进一步操作
- 4xx:客户端错误 ——请求有语法错误或者请求未能实现
- 5xx:服务器端有错误： 服务器端未能合法实现

 

#### 浏览器解析渲染页面

![WebKit渲染过程](https://segmentfault.com/img/bVCZ1H?w=694&h=340)

![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)

### HTTP是不保存协议，如何保存用户状态

http是不保存状态，即无状态(stateless)协议，通过Session机制可以解决这个问题，HTTP是无状态的，服务器给这个用户创建特定的Session之后就可以标识这个用户并且跟踪这个用户了

在服务端保存Session的方式很多，最常用的就是内存和数据库(比如内存数据库redis保存)  Session存在服务器端我们是通过Cookie附加一个SessionID进行跟踪的

#### Cookie被禁用怎么办

利用URL重写将Session ID直接附加在URL路径后面

##  TCP 三次握手和四次挥手(面试常客)

![image-20220626221139008](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220626221139008.png)

### TCP 三次握手漫画图解

![TCP三次握手](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

![TCP三次握手](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png)

![img](https://img-blog.csdnimg.cn/img_convert/0c9f470819684156cfdc27c682db4def.png)

### 为什么要三次握手

第一次握手：Client（下文简称C）什么都不能确认，Server(下文简称S)可以确定C的发送正常，S的接收正常

第二次握手：C可以确认自己的发送正常，接收正常，S的发送、接收正常，（但是S不能确定S的发送正常，C的接收正常，所以需要进行第三次握手）

第三次握手：S确认自己发送正常，对方接收正常

![在这里插入图片描述](https://img-blog.csdnimg.cn/114bd9b53c554319ae0db15b57b472b8.gif#pic_center)

![img](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2?x-oss-process=image/format.png)

#### **解释版本：**

1. TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
2. TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，**SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。**
3. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。**这个报文也不能携带数据，但是同样要消耗一个序号。**
   TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。**TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。**
4. 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

#### 为什么TCP客户端最后还需要发送一次确认

> 为了防止已经失效的请求连接又传送到了服务器，发生请求错误

如果使用的是两次握手连接，那么可能发送这种场景，**客户端发送第一个请求没有丢失，只是在网络节点中滞留的时间太长了**，TCP客户端没有收到这个报文，以为服务器没有收到，所以就又发了一条报文到服务器，然后服务器和客户端经过两次握手建立连接，如果此时网络通畅了，这个报文本来是失效的，那么就可能引起不必要的资源的浪费，但是三次握手不会出现这种情况是因为，服务端给客户端发送响应之后，客户端不会发送相应的确认

### 第二次握手传回ACK，为什么还需要传SYN

接收端传回ACK是为了告诉客户端，我接收到你的消息，说明客户端到服务端的通信是正常的，回传SYN是为了建立并确认服务端到客户端的通信

> SYN同步序列编号是TCP/IP建立连接使用的握手信号，在客户端和服务器建立正常的TCP连接，客户端先发送SYN请求，然后服务端发送SYN-ACK应答，然后客户端发送ACK响应，数据才可以在客户端和服务器传递

###  为什么要四次挥手

| 四次握手 | 第一次 | 第二次 | 第三次 | 第四次 |
| -------- | ------ | ------ | ------ | ------ |
| FIN      | 1      |        | 1      |        |
| ACK      |        | 1      | 1      | 1      |
| seq      | m      | n      | p      | m+1    |
| ack      |        | m+1    | m+1    | p+1    |



![TCP四次挥手](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)



![在这里插入图片描述](https://img-blog.csdnimg.cn/0c17d72769aa4bd2b95bbaee1749b39d.gif#pic_center)

![四次挥手](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format.png)

> 数据传输完毕之后，双方都可释放连接，最开始的时候，客户端和服务端都是ESTABLISHED,然后客户端主动关闭

1.客户端发送连接释放报文，并且停止发送数据，释放报文首部，FIN=1，序列号seq= u(等于前面传送过来数据的最后一个字节+1),此时客户端进入FIN-WAIT-1状态（终止等待1状态）。 **TCP规定，FIN即使不携带数据，也要消耗一个序号**

2.服务端接收报文，发送确认报文，ACK=1 ,ack= u+1,并且发送自己的序号seq = v ，然后服务器进入CLOSE_WAIT状态 **TCP服务器通知高层应用，客户端想服务器要释放了，这时候处于半关闭状态，此时客户端没什么向服务器发送的，但是服务器发送数据客户端还要接受**  **这种状态还需要持续一段时间，也就是整个CLOSE_WAIT的时间**

3.客户端接收服务器的请求之后，客户端进入FIN-WAIT-2(终止等待状态)，等待服务器发送连接释放报文**(在这之前还要接受服务器发送的最后的数据)**

4.服务器在最后数据发送完毕，就像客户端发送了连接释放报文，FIN=1,ack=u+1,因为在半关闭状态，服务器可能又发送了一段信息，我们假定序列号为seq  = w，**此时服务器进入了LAST-ACK(最后确认状态)，等待客户端最后的确认**

5.客户端收到服务器的连接释放报文之后，必须发送确认，ACK=1, seq = u+1,而自己的序列号是w+1，此时，客户端进入TIME-WAIT(时间等待)状态， **注意，此时TCP还没有释放，必须经过2*MSL(最长报文段寿命)时间后，当客户端撤销相应TCB，才能进入CLOSED状态**

6.服务器只要收到了客户端发出的确认，就立即处于CLOSED状态， 撤销TCB后就撤销了本次连接， **可以看到，服务器结束TCP连接比客户端早一些时间**

### 为什么客户端最后还要等待2MSL？

 MSL(Maximum Segment Lifetime),TCP允许不同的实现设置不同的MSL值

第一，保证客户端发送的最后一个ACK报文达到服务器，因为这个ACK可能丢失， **站在服务器角度，我已经发送FIN+ACK报文段请求断开了，但是客户端没有回应，应该是没有收到我的请求报文，所以服务器应该会重发一份**，客户端可以在2MSL时间内接收这个重传的报文段，然后给回应报文，并且会重新开启2MSL计时器

第二  防止类似与“三次握手”提到的“已经失效的连接请求报文段”出现在连接中，客户端发送最后一个确认报文，在2MSL时间，可以让本连接持续的时间所有的报文段从网络消失

### 为什么连接是三次握手，关闭是四次挥手

**建立连接的时候**，服务器处于LISTEN状态下，收到建立连接请求的SYN，把ACK和SYN放在一个报文发送到客户端

**关闭连接的时候**，服务器收到对方的FIN报文，仅仅表示对方不在放松信息了，然后自己发送ACK表示自己确认收到对方的关闭请求里，但是自己可能有些东西没有发完，所以需要自己在发送一些消息，然后发送关闭请求连接FIN，所以因为ACK和FIN分开发送，所以导致多了一次

### 如果已经关闭连接，但是客户端故障了怎么办

TCP设置有一个保活计时器，显然，如果计时器故障，服务器不能一直白等下去，白浪费资源，服务器每次收到客户端请求都会重置这个计时器，一般时间是两小时，如果两小时没有收到，服务器会发送探测报文段，每隔75秒发送一下，如果发送10个没有反应就认为客户端有问题

##  TCP, UDP 协议的区别

### TCP结构

![image-20220908110645105](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220908110645105.png)

![TCP、UDP协议的区别](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg)

UDP在传送数据之前不需要先建立连接，远程主机接收到UDP报文段之后不需要给出确认，UDP一般用于即时通讯，比如：QQ语音，QQ视频，直播

TCP提供面向连接的服务，在数据传输之前必须建立连接，数据传输之后要释放连接，而且在数据传递的时候有，确认，窗口，重传，拥塞控制机制，这难以避免有很多开销

一般用于文件传输，发送接收邮件，远程登录等操作

## TCP 协议如何保证可靠传输

1. 数据被分割为TCP认为最合适的数据块
2. TCP对每一个包进行编号，接收方对数据包进行排序，将有序数据传送到应用层
3.  **校验和：** TCP保持首部和数据的校验和，这是一个端到端的校验和，目的是为了传输过程中检测数据没有受到修改，如果收到的报文段首部和数据校验和有误，TCP将丢弃该报文段和不确认收到的报文段
4. TCP接收端会丢弃重复的数据
5.  **流量控制：** TCP链接的每一方都有固定的缓冲大小，TCP的接收端只允许发送端发送接收端允许容纳的数据，当接收方来不及处理发送方的数据，可以提示发送方降低数据发送的速率
6.  **拥塞控制**：当网络拥塞时，减少数据的发送
7.  **ARQ协议：** 为了实现可靠传输， 基本原理：每发完一个就分组停止发送，等待对方确认，收到确认之后进行下一个分组
8.  **超时重传**：TCP发出一个段，启动定时器，等待目的端收到报文段， 如果不能及时确认，则重发这个报文段

### ARQ 协议

**自动重传请求（Automatic Repeat-reQuest, ARQ ）**是OSI模型 数据链路层和传输层错误纠正协议之一。通过超时和重传两个机制，在不可靠服务的基础上实现可靠的信息传输机制，如果发送方在发送后一段时间没有收到确认帧，通常重新发送

ARQ包括停止等待ARQ协议和连续ARQ协议

#### 停止等待 ARQ 协议

停止等待协议是为了实现可靠传输，  原理：每发送完分组就停止发送，等待对方确认，过了一段时间（超时时间），没有收到ACK确认，就重新发送

停止等待协议中，若接收方收到重复分组，就丢弃该分组，同时也要确认

**优点：**简单

**缺点：**效率低，信道利用率低

**1) 无差错情况**：

发送发发送分组，接收方在规定的时间收到并且确认，发送方继续发送

**2)出现差错情况：(超时重传)**

如果超时就重传，因此每个分组都需要有一个超时计数器，这种称谓 **自动重传ARQ**，另外停止等待协议若收到重复分组，就丢弃该分组，并且发送确认

**连续ARQ协议**可以提高信道利用率，维持一个发送窗口，位于发送窗口的分组可以连续发送出去

**3)确认丢失和确认迟到**

**确认丢失：**确认消息再传输过程中丢失，当A发送M1消息，B给A发送M1确认消息，但是在传输过程中丢失，但是A不知道，A重传M1

B有两种措施：

1.丢弃这个重复M1消息，不向上层交付

2.向A发送确认消息

**确认迟到：**确认消息再传输过程中迟到。A发送M1消息，B收到并且发送确认。A重传M1消息，B收到继续发送确认消息，这时候B有两份M1消息，A有两份确认消息。

1.A收到重复确认，直接丢弃

2.B收到重复M1，也丢弃M1

#### 连续ARQ协议

连续ARQ协议可提高信道利用率，发送方维持一个发送窗口，位于发送窗口可以连续发送出去，不需要等待对方确认。接收方采用累积确认， 对于按序到达的最后一个分组确认，表示确认所有的分组

**优缺点：**

**优点：**信道利用率高，容易实现，即使确认丢失，也不必重传

**缺点：**不能向发送方反映出接收方确认收到的所有分组的信息，如果有五条消息，第三条丢失，那么后三条都需要重发，也叫回退N

### 滑动窗口和流量控制

**TCP利用滑动窗口实现拥塞控制。流量控制室为了控制发送方的发送速率，保证接收方正常接收**

接收方确认报文的窗口字段可以控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则不能发送数据

### 拥塞控制

在某段时间，若网络对某一资源的需要超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况叫做拥塞

拥塞控制是为了防止过多数据注入到网络，这样是网络中的路由器和链路不至于过载

**拥塞控制和流量控制**

拥塞控制是全局性过程，涉及到所有主机，路由器，以及降低网络传输的因素

流量控制是点对点的通信量机制，是端到端问题。 流量控制就是要一直发送端发送的速率，便于接收端接收

TCP拥塞控制有四种办法， **慢开始**  **拥塞避免**  **快重传**  **快恢复**

- **慢开始：** 如果主机开始发送数据时，立即发送大量数据字节到网络可能引起网络阻塞，较好的方法是先探测一下，然后从小到大加大发送窗口，刚开始 cwnd为1 ，每经过一个传播轮次将cwnd加倍
-  **拥塞避免：** 将cwnd缓慢加大，然后通过往返时间RTT把cwnd加1
-  **快重传和快恢复：**在TCP/IP中，快速重传和恢复是拥塞控制算法，能快速恢复丢失的数据报，如果包丢失了TCP用定时器来要求传输暂停。有了FRR就不会因为重传要求的暂停被耽误。如果接收到一个不按顺序的数据段，会给发送机一个重复确认。

## TCP协议是如何恢复数据的顺序

### Seq和Ack

![image-20220630210850871](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220630210850871.png)



## 拆包和粘包的作用

TCP一次把数据拆分成多个部分，然后逐个发送

### 问题：计算机为什么不一次发送完所有的数据

1. 稳定性，一次发送完全部数据，容易出现差错和丢包的概率大
2. 效率，网络存在并行路径拆包能利用这些并行的路径
3. 内存中存在缓冲区，缓冲区会实时接收不同应用的数据，如果缓冲区处理不过来拿其他的应用就需要排队，如果计算机允许任意时刻有应用发送大数据文件，那么会对其他应用的效率和使用带来影响
4. 内存分配的最小分配单位是页表，如果分配的内存超过页表就需要进行页面置换，造成性能消耗

### 黏包和拆包

所以我们需要把数据拆分，然后到目的地进行重组，这一过程叫做**拆包**

如果数据段过小，我们把他合成一个TCP段发送，到目的地重组，这一过程叫做粘包

### TCP段需要关注字段

- **URG**：比较紧急的字段，比如计算机需要临时关机
- **PSH**：消息推送字段，传送数据
- **ACK**：消息确认字段，所有消息都需要有ACK，这个是TCP
- **SYN**：同步请求，请求握手
- **FIN**：终止请求，挥手请求



## 滑动窗口

![image-20220630202255912](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220630202255912.png)

上述的四色，我们是使用 **滑动窗口**的形式去实现的

- 深绿色表示已经发送并且收到了ACK的段
- 浅绿色代表已经发送但是还没收到ACK的段
- 白色代表没有发送的段
- 紫色代表暂时不能发送的段

我们发送这些包等待接收ACK，如果有一个封包ACK到达，我们就把它标位已接收，

![image-20220630202536632](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220630202536632.png)



然后有两个封包ACK到达，标位绿色，然后窗口移动

![image-20220630202912282](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220630202912282.png)

### 重传

![image-20220630203003352](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220630203003352.png)

如果段4收不到ACK，那么滑动窗口会继续向右移动一个单位

![image-20220630203637210](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220630203637210.png)

然后断4重发，重传成功（收到ACK）窗口就会右移，如果段4发送失败，接收方会抛弃端5，6，7，从段4开始的数据都需要重新发

### 快速重传

TCP协议，如果想抛弃哪个段，可以选择不发ACK，超时后，发送方会重发这个段

接收方如果希望发送方快点发送某个TCP段，可以 **快速重传**

例如 1，2，4段到了，但是没有段3，接收方可以发送多个段3的ACK。接收方如果收到多个段3的ACK，就会重发段3 **这就是快速重传**

## 流速控制

**发送，接收窗口的大小可以控制TCP协议的流速**，窗口越大，接收的数据越多，支持吞吐量越大， 但是窗口越大，容易出错也越多，损失越大

## 总结

TCP协议可以选择多个段进行发送，为了不让这些段拒绝服务，我们在发送前要协商好发送速率

有了窗口，发送方利用滑动窗口算法发送消息，接收方构造缓冲区接收消息，并发送给ACK

### 滑动窗口和流速控制是怎么回事

**滑动窗口是TCP协议的核心**，发送方先把数据拆包，分成多个分组，然后将数据放在一个滑动窗口的数组中，依次发出，并且仍然遵循这先进先出（FIFO）原则，不过位于滑动窗口中的数据是一次性发出的，如果窗口中序号最小的分数收到了ACK，窗口就会向右滑动； 如果序号最小的分组长时间没有收到ACK，就会触发整个窗口重新发送

## TCP和UDP

UDP在数据传输，网络控制，音视频，Web技术都有很重要的位置

### UDP协议

**UDP（User Datagram Protocol）**   **目标是在传输层直接发送报文(Datagram)的能力**

**问题**：为什么不能直接调IP协议

因为传输层承接应用层的调用，提供应用到应用之间的通信——需要附上端口号，IP协议承接传输层的应用，将数据从主机传输到主机上，**IP层不能区分应用**

### 封包格式

![image-20220630212253859](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220630212253859.png)

UDP报文十分简化，只有五个部分

- Source Port是源端口号，因为UDP（不需要ACK），所以这个字段是可以省略，**但是对于防火墙，代理来说Source Port很有意义，不可以省略**
- **Destination Port**： 目标端口号(不可以省略)
- **Length**:消息体长度，不可以省略
- **Checksum**：校验和，判断传输是否出错
- **Data Octets**:一个字节一个字节的数据，octets是八位

UDP的可靠性知识CheckSum一种，如果校验和改表大量数据校验和也有可能发生碰撞(和原来的值匹配)

### UDP和TCP的区别

![tcp-vs-udp](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/Pictures/Saved%20Pictures/tcp-vs-udp.jpg)

如果希望保证传输的安全性，选用TCP合适，但是如果希望传输速率足够快，选用可能选用UDP，但是想要把网路优化到机制，就会用UDP作为底层基础，从UDP基础解决可靠性。

**理论上，热和一个用TCP协议构造的成熟的应用层协议，都可以用UDP重构**

### TCP和UDP的场景

#### **第一类：TCP场景**

- 远程控制（SSH）
- FTP
- 简单邮箱传输协议(SMTP)
- 点对点文件传出

#### **第二类：UTP场景**

- 网络游戏
- 音视频传输
- DNS
- Ping
- 直播

#### **第三类模糊地带**

- HTTP（目前以TCP为主）
- 文件传输

# IP层常见协议

**结构**

![image-20220908112901390](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220908112901390.png)

## IPv4协议:路由和寻址的区别

### 什么是IP协议

**IP协议是在网络层处于垄断地位的网络协议**,IPv4就是IP协议的第四个版本

IPv4提供Host-to-Host的能力，但是底层需要数据链路层的支持

![image-20220701105033282](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220701105033282.png)

IP协议并不负责数据的可靠性，数据传输时，数据被切分成一个个数据封包。IP的上层传输层会对数据进行一次拆分，IP层也会对数据进行一次拆分，这样做的目的是为了适配底层设备

数据在网络中传输，并不需要预先建立连接，而是任由数据在网络传输，通过路由算法帮助封包达到下一个目的地

>  **可靠性保证数据无损的到达目的地**， 可靠性是IP协议上方Host-to-Host保证的，比如TCP协议是通过应答机制，窗口等保证数据可靠性,.IP协议自身不保证可靠性

IP协议可能会遇到下面几个问题

- 封包损坏(数据传输过程中封包被损坏)
- 丢包（数据发送过程中包丢失）
- 重发（数据被重发）
- 乱序(到达目的地的数据的发送时候的数据不一样)

但是网络层不会处理这些问题，网络层只专注解决网络层的问题

- 延迟
- 吞吐量
- 丢包率

### IP协议工作原理

**IP协议接收IP协议上方的Host-To-Host传来的数据，然后进行拆分，这个能力叫做分片**，然后IP协议为每个片段(Fragment数据报)加上IP头（Header）组成 **IP封包**，然后通过底层(数据链路层)传输数据，通过IP寻址和路由能力把封包送到目的地

**分片（Fragment）**

**分片就是把数据切分成片**，IP协议通过下一层(数据链路层)传输数据，因此数据大小需要符合数据链路层，所以需要适配传输网络的传输能力， 数据太大就不适合底层数据传输，就需要切片，也可能不切片当底层看不到切片的封包又没有传输能力时，就会丢弃这个封包

**增加协议头（IP Header）**

![image-20220702160220112](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220702160220112.png)

分成四个部分：

- 原地址和目标地址，IPv4的地址是4组8为的数字
- Type of service指的是服务的类型， 选择延迟，吞吐量，丢包率的关系
- IHL描述IP协议头的大小，最大是1111=15,最大双子是15*32bit=15乘以4字节
- Total Length：定义封包长度
- Identification(id)：发送方分配，代表顺序
- Fragment offset:要不要分包(如何拆分)
- Time to time :封包活着的时间
- Protocol:上层协议，6代表TCP，17代表UDP
- Options:封包正确性
- Checksum: 检验封包正确性(校验和)，不对的就要舍弃

### 延迟，丢包率，吞吐量

#### **延迟**

延迟指的是**1bit数据从网络一个终端发送到另外一个终端需要的时间**，时间包括

- 准备发送的时间
- 排队发送的时间
- 发送数据的时间
- 传输数据的时间

#### 吞吐量

**吞吐量指的是单位时间可以传输的平均数据量,bit/s(bps)**,吞吐量和延迟没有关系，比如大水管留的快和小水管流的慢

#### 丢包率

丢包率指的是发送出去的封包没有到达目的地的比例， 最大流速确定的网络中，丢包率直接影响到吞吐量

丢包率我们希望尽可能小

Type of service中我们可以选择四种类型

- 低延迟
- 高吞吐量
- 低丢包率
- 低成本

### 寻址

#### 寻址过程

![image-20220702164544899](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220702164544899.png)

1.找到底层网络

~~~bash
103.16.3.1 & 255.0.0.0 = 103.0.0.0
~~~

2.找到下一层网络

~~~bash
103.16.3.1 & 255.255.0.0 = 103.16.0.0
~~~

3.找到再下一层网络

4.定位设备

![image-20220702165308005](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220702165308005.png)

- Destination:14.0.0.0
- Gateway:16.12.1.100
- Mask:255.0.0.0
- Iface:16.12.1.1

需要去往14.0.0.0网络 ，IP地址需要跟255.0.0.0进行位运算，然后查表14.0.0.0

，得知去GateWay的网卡(Iface)是16.12.1.1

### 总结

#### 寻址和路由的区别

寻址是通过地址找设备，和现实生活中的寻址是一样的

路由（Routing）本质是路径选择，知道地址，但是比如到了十字路口，还需要进行具体路径的选择

做路由，需要借助寻址的能力，通过寻址找到最终的设备，寻址有需要路由选择线路，所以二者是相辅相成的

## IPv6:Tunnel技术是什么

### IPv6地址

Ipv4地址是4个8位，IPv6地址是8个16位

![image-20220702172537252](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220702172537252.png)

IPv6地址完全态

~~~bash
0123:4567:0000:0000:0123:4567:0000:cdef
~~~

可以省略前64位中的`0000:0000`

~~~bash
0123:4567::0123:4567:0000:cdef
~~~

开头的0也可以简写

~~~bash
123:4567::123:4567:0:cdef
~~~

### 寻址

![image-20220702173413857](C:/Users/%E4%B8%BF%E5%89%91%E6%9D%A5%C2%B7/AppData/Roaming/Typora/typora-user-images/image-20220702173413857.png)



## Mac地址

#### 结构

![image-20220909094255849](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220909094255849.png)

MAC头的协议类型只用：

- `0800`:IP协议
- `0806`:ARP协议

#### Mac报文生成

![image-20220909094720396](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220909094720396.png)

> 加上了MAC头部，就可以到达目的地了

### 出口（网卡）

> 网络包只是存放在内存上的一串二进制数字信息，我们需要把  **数字信号转为电信号**
>
> 网卡驱动获取网络包之后，会 **复制**到网卡的缓存区，然后在其 **开头加上报头和起始帧分界符，末尾用于检测错误的帧校验序列**

 ![image-20220909095636664](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220909095636664.png)

- 起始帧分解符是用来表示包起始位置
- 末尾`FCS`(帧校验序列)检查包传输是否损坏









# 计算机专题学习

## 三次握手连接阶段，最后一次ACK包丢失怎么办

**服务端**：

- 第三次ACK在网络中丢失，此时服务端会处于SYS_WAIT的状态，根据TCP的超时重传机制，服务端每隔3秒，6秒，12秒会重新发送一次SYN+ACK包， 便于服务端发送ACK包
- 重发指定次数后，客户端仍然未收到ACK应答，服务器会关闭这次连接

**客户端**：

客户端默认链接建立，如果客户端给服务端发送数据，服务端会发送RST包（Reset包，标志复位）相应，客户端收到请求会知道第三次握手失败

## 为什么客户端的TIME_WAIT必须等待2MSL

**1.确定报文段能够正常到达服务端，使服务端连接关闭**

第四次回收，客户端第四次回收ACK不一定到达服务端，服务端会超时重传FIN/ACK，这时候如果客户端关闭就会收不到FIN/ACK，就会导致服务端得不到及时关闭

2.确定报文段都在网络中消失

客户端发完最后一个2ACK，经过2MSL，可以保证本连接持续的时间内报文段在网络中消失



## TCP的滑动窗口

# 











