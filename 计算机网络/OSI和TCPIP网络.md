WOSI 和 TCP/IP 网络分层模型详解（基础）

##  OSI 七层模型

  **OSI七层模型**是国际化标准组织提出的一个网络分层模型，

![osi七层模型](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png)

每一层专注做一件事情，并且每一层都需要使用下一层提供功能

**OSI七层体系结构，概念清除，理论完成，但是复杂不常用**

![osi七层模型2](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png)

**为什么OSI七层模型干不过TCP/IP四层模型**

1. OSI专家缺乏实际经验，OSI完成的标准缺乏商业驱动力
2. OSI协议实现复杂
3. OSI指定周期长
4. OSI层次划分不合理，有的功能在多个层次重复出现

![img](https://javaguide.cn/assets/osi-model-detail.69f69153.png)

## TCP/IP 四层模型

TCP/IP模型是目前广泛采用的一种模型，我们可以让TCP/IP模型当做是OSI七层模型的精简版

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

![TCP-IP-4-model](https://javaguide.cn/assets/TCP-IP-4-model.6ae180f1.png)

### 应用层（Application layer）

**应用层在传输层纸上，提供两个终端设备的应用程序之间信息交换的服务，定义了信息交换的格式，消息会交给下一层传输层传输**

![img](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/5971-2-7I1-20220111095024771-20220111201807861.png)

应用层定义了网络通信规则，对于不同的网络应用需要不同的应用层协议，比如支持Web的HTTP协议，支持电子邮件的SMTP协议

![application-layer](https://javaguide.cn/assets/application-layer.a60c27d2.png)



### 传输层（Transport layer）

**传输层就是负责在两台终端设备之前通信提供通用的传输服务** 

应用进程利用该服务传送应用层报文

**运输层主要提供如下两个协议：**

1. **传输控制协议TCP**（Transmission Control Protocol） 提供  **面向连接的 可靠的**数据传输服务
2.  **用户数据协议UDP**（User Datagram  Protocol ）  提供  **无连接的**，尽最大努力的数据传输服务

![transport-layer](https://javaguide.cn/assets/transport-layer.3d064ed5.png)

### 网络层（Network layer）

**网络层负责为分组交换网上不同的主机提供通信服务**，在发送数据时候，网络层将运输层产生的报文段或者用户数组封装成分组或者包进行传送

**不要把运输层 用户数据包“UDP”和用户层的 "IP数据报搞混"**

**网络层还有一个作用就是选择合适的路由，使源主机运输层传下来的分株，能通过网络层路由器找到目的主机**

互联网是大量异构网络通过路由器相互连接起来，互联网的协议是无连接的网际协议和许多路由协议，  这样构成了**网络层和IP层**

![img](https://javaguide.cn/assets/nerwork-layer.688b8282.png)

### 网络接口层(Network Interface layer)

我们可以把网络接口层看做数据链路层和物理层的合体

1.数据链路层通常简称链路层  **数据链路层的作用是将网络层传下来的IP数据封装成帧，然后在链路上传递帧，每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制）**

2.物理层的**作用是实现相邻节点的比特流的传输，尽可能屏蔽传输介质和物理设备的差异**

![network-interface-layer](https://javaguide.cn/assets/network-interface-layer.c1c4efcc.png)

## 为什么网络要分层？

对于分层，我们一般会把系统分为三层(复杂的系统分层会更多)

1.Repository (数据库操作)

2.Service(业务操作)

3.Controller(前后端数据交互)

**复杂的系统需要分层，因为每一层需要只专注于一件事情，网络分层原因也一样，每一层只专注于意见事情**

**原因：**

**1.各层之间相互独立**

**2.提高整体的灵活性**

**3.大问题化小**

# HTTP vs HTTPS（应用层）

##  HTTP 协议

###  HTTP 协议介绍

HTTP协议叫做超文本传输协议(Hypertext Transfer Protocol), HTTP就是规范超文本的传输，超文本，就是网络上包括文本在内的各种各样的消息，总的来说就是规范浏览器和服务器的行为的

HTTP是**无状态(stateless)协议**,也就是服务器不维护任何有关客户端所发请求的消息，有状态协议更复杂，需要维护历史信息，如果客户端或者服务器失效会产生状态的不一样，这样的代价会更高

### HTTP 协议通信过程

HTTP是应用层协议，以TCP为底层协议，默认端口为80

- 1.服务端在80端口等待HTTP请求
- 2.浏览器发起到服务器的TCP连接（创建Socket套接字）
- 3.服务器接收来自浏览器的TCP链接
- 4.浏览器（HTTP客户端）和Web服务器（HTTP服务器）交换HTTP消息
- 5.关闭TCP连接

### HTTP协议优点

扩展性好，跨平台型支持好，速度快

## HTTPS 协议

### HTTPS 协议介绍

HTTPS协议（Hyper Text Transfer Protocol Secure）是HTTPS的加强安全版本，

HTTPS协议是基于HTTP的，也是使用TCP作为底层协议，并且使用SSL/TLS作为加密和安全认证，端口是443

HTTPS中SSL通常使用基于密钥的加密算法，密钥的长度一般为40bit或128bit

### HTTPS 协议优点

保密性好，信任度高

### HTTPS 的核心—SSL/TLS协议

HTTPS之所以能达到较高的安全要求，就是结合了SSL和TLS的协议，对通信进行加密，解决了HTTP数据透明的问题

SSL 和 TLS 的区别

没有太大区别，

SSL是 安全套接字协议（Secure Sockets Layer）,首次在1996年发布，已经是SSL的3.0, 之前两个版本都有缺陷，在1999年，SSL3.0命名为TLS，TLS是在SSL之上的，但是由于习惯，我们一般把HTTPS加密协议混为SSL/TLS

SSL的工作原理

非对称加密

SSL/TLS的核心要素是 **非对称加密**吗，密钥是解密者保存，公钥是任何一个想和解密者通信的发送者所有

> 公钥只能加锁，不能解锁，  比如发送者想要发送信息，先用公钥加锁，然后接受者用密钥解锁，就可以解密信息

![img](https://javaguide.cn/assets/public-key-cryptography.22f51898.png)

非对称加密的公钥和密钥是采用复杂的数学机制生成的,  **公私钥的生成算法依赖于单向陷门函数**

> 单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。
>
> 单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。

![单向函数](https://javaguide.cn/assets/OWF.e638a930.png)

#### 对称加密

**使用SSL/TLS进行双方通信需要使用非对称加密通信**，但是非对称加密的算法实现比较复杂，计算代价高，效率低，所以对**消息的加密**用的是对称加密

>对称加密：通信双方使用唯一密钥k，加密算法已知，加密方通过密钥k加密，解密放通过密钥k解密，保密性依赖于密钥k的保密性

![image-20220706215027485](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220706215027485.png)

对称加密的密钥代价比公私钥的生成代价低得多，为什么还需要一层非对称加密，因为对称加密的保密性依赖于密钥的保密性，**在双方通信之前，需要商量一个对称加密的密钥**，  我们认为网络中信道不安全，传输报文任何人可见，所以我们需要保证对称加密安全的情况，  **解决方法是先使用非对称加密，对于对称的密钥进行加密，保证密钥不在网络信道被窃听**，  这样通信双方只需要一次非对称加密，交换对称加密的密钥，  之后通信使用安全的密钥对消息进行对称加密

####  公钥传输的信赖性

> 客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：
>
> 1. 任何人都可以捕获通信包
> 2. 通信包的保密性由发送者设计
> 3. 保密算法设计方案默认为公开，而（解密）密钥默认是安全的
>
> 因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。
>
> 同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！

![image-20220706215422938](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220706215422938.png)

为了解决公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Centificate Authority）,CA默认是信任的第三方。CA会给各个服务器颁发证书，证书存储在服务器，并且附有CA的 **电子签名**

客户端(浏览器)向服务器发送HTTPS请求时候，一定要**先获取目标服务器的证书**，根据证书的信息，检验证书合法性，检测证书非法，就发生错误，**客户端获取服务器的证书，  证书的信任性是第三方依赖机构认证的，证书上又包括服务器的公钥信息**，客户端就放心的信任证书的公钥就是服务器的公钥了

#### 数字签名

 数字签名的作用就是为了防止证书被伪造。第三方信赖机构CA之所以可以被信赖，就是靠 **数字签名技术**

数字签名是在证书颁发的过程中，通过 **散列+加密**的技术，给证书发个章，进而提供校验真伪的功能

>  CA知道服务器公钥，对该公钥通过散列技术进行生成摘要，CA会对CA公钥进行加密，并附在证书下方
>
>  服务器将证书发给客户端，客户端需要验证证书身份，然后找到CA获取CA公钥进行解密，获取CA获得的摘要
>
> 另一方面 客户端对证书数据（服务端公钥）进行散列处理，得到摘要，然后和之前的摘要对别，相同，则身份验证成功

![img](https://javaguide.cn/assets/digital-signature.6fb25ead.png)

带有**证书的公钥传输机制如下：**

1.设有服务器S，客户端C和第三方依赖机构CA

2.S信任CA，CA知道S的公钥，CA向S颁发证书，并附上CA私钥对消息摘要的签名

3.S获得CA颁发的证书，并且将证书传给C

4.C获得S的证书，信任CA并且知道CA公钥，通过CA公钥对S上的签名解密，并且对消息进行散列处理获取CA私钥，得到摘要，比较摘要，验证S证书的真实性

5.如果C验证S的证书是真实的，就信任S的公钥

## 总结

**端口号：**HTTP默认是80端口，HTTPS默认是443端口

**URL前缀：**HTTP的url前缀是 `http://`, HTTPS的URL前缀是 `https://`

**安全性和资源消耗：**

HTTP运行在TCP协议之上，所有传输内容都是明文传输，Server和Client都无法验证双方

HTTP是在SSL/TLS之上的协议，SSL/TLS运行在TCP上，传输内容经过对称加密，但是对称加密的密钥用服务器方的证书用了非对称加密

HTTP安全性没有HTTPS高，HTTPS比HTTP更耗费服务器资源

