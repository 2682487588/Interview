# 二

## 2.

### 2.进程基本状态和转换

- 就绪(Ready)
- 执行(Running)
- 阻塞(Block)

![进程切换](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220822221018096.png)

### 3.创建状态和终止状态

1） **创建状态**

1. 进程申请PCB
2. 将PCB填写于控制和管理进程的信息中
3. 分配进程需要的资源
4. 插入就绪队列

2）**终止状态**

1. 操作系统善后处理
2. PCB清零
3. PCB空间返还给系统

![image-20220822222042174](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220822222042174.png)

### 4.进程管理的数据结构

#### 1.操作系统用于管理控制的数据结构

![image-20220822223400242](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220822223400242.png)

#### 2.进程控制块PCB

> 使一个多道程序下不能独立运行的程序称为一个能独立运行的基本单位

1)  作为独立运行的基本单位的标志(程序运行的时候创建PCB，程序停止的时候收回)
2) 实现间断性的运行方式（保留CPU运行现场）
3) 提供进程管理需要的信息（PCB包括记录程序和数据在内存和外存的起始指针以及进程所需的全部资源）
4) 提供进程调度需要信息
5) 实现和其他进程的同步和通信

## 3.进程控制

### 1.OS内核

1.系统态：（管态，内核态）执行一切指令，访问所有寄存器和存储区，传统OS在系统态执行

2.用户态：（目态）执行特定命令，访问特定的寄存器和存储区，一般情况，应用程序只能在用户态

**OS提供两大功能**

1.**支撑功能**

1. **中断处理**
2. 时钟管理
3. 原语操作

2.**资源管理功能**

1. 进程管理
2. 存储器管理
3. 设备管理

## 4.进程同步

### 1.基本概念

#### 两种制约关系

##### 1.直接制约关系

> 相互合作，顺序的完成一个任务

##### 2.间接制约关系

> 为了同样的任务，相互互斥的访问资源

#### 2.临界资源

> 打印机，磁带机都属于临界资源 ， **各个进程需要用互斥的方式进行访问**

#### 3.临界区

>  每个进程**访问临界资源的那段代码** 叫做临界区

#### 4. 同步机制遵循规则

1. 空闲让进
2. 忙则等待
3. 有限等待
4. 让权等待

### 3.信号量机制

**信号量机制是为了解决进程间的互斥和同步问题而产生的**

#### １.整型信号量

> 整形信号量（整量S）除了初始化，只能通过wait和isignal操作进行访问，这两个操作也称为P,V操作

#### 2.记录型信号量

> 整形信号量只要S<=0就会一直测试，出现忙等，**违反"让权等待"原则**
>
> 记录性信号量 一个是整形value,另外一个是进程链表指针List，存储等待进程

![image-20220823101029836](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220823101029836.png)



### 5.管程机制

**信号量缺点：** 各个系统使用他们都需要自备wait和signal，还容易操作不当形成死锁

#### 1.管程定义

系统硬件资源和软件资源可以抽象成数据结构表现其资源特性，用少量信息和资源执行操作表征这个资源

## 5.经典进程同步问题

> 生产者

![image-20220823140154771](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220823140154771.png)

> 消费者

![image-20220823140234929](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220823140234929.png)

## 6.进程通信

> **低级通信**:信号量机制

1. 效率低
2. 通信对用户不透明

> **高级通信**：（原语等）

1. 使用方便
2. 高效传输大量数据

### 2.消息传递通信方式

**1.直接消息传递系统**：发送进程利用OS发送命令，直接把消息发送给目标进程

## 7.线程

1.**进程基本属性**

- 可拥有资源的基本单位
- 独立调度和分配资源的基本单位

2.**程序并发所需时间开销**

- 创建进程
- 销毁进程
- 进程切换

3.**线程——调度和分配的基本单位**

> 我们既想程序可以更好的并发执行，又想尽量减少系统开销，就需要引入更为轻量的线程

### 2.线程和进程对比

1. 切换：进程每次调度需要切换，线程切换开销小
2. **资源拥有**：进程资源分配和拥有的单位，线程是调度的单位
3. 线程是处理器调度的基本单位，线程不是
4. 二者可并发执行

### 3.协程和线程区别

1. 一个协程可以有多个线程，一个进程也可以有多个线程
2. 线程是同步操作，协程是异步操作
3. 线程是抢占式的，协程是非抢占式的，需要用户进行调用和释放
4. 协程可以保存上一次调用的状态，每次过程重入之后，就相当于进入上一步的状态
5. 协程不是取代线程，而是抽象与线程至上，运行还是需要协程进行运行的，线程是协程的资源

## 8 线程的实现

#### 1.内核支持线程KST

内核空间实现线程的创建，阻塞，撤销，转换

**优点：**

- 1.多处理器系统，内核的能够调度多个线程同时执行
- 2.即使一个线程发生阻塞，内核仍然可以调度该进程的其他线程或者其他进程的线程
- 3.内核具有更小的数据堆栈，调用线程的开销更小
- 4.采用多线程技术，使得系统执行效率更快

**缺点：**开销大，因为需要从用户态转为核心态，因为用户线程管理是用户态，线程调度是内核态

#### 2.用户级线程ULT

**优点：**

- 1.线程切换不需要通过内核空间
- 2.调度算法是进程专用
- 3.用户级线程实现和OS平台无关

缺点：

1. 如果系统调用会发生阻塞
2. 用户级实现方式，内核只能每次分配一个CPU

# 三、处理机调度和死锁

## 1.调度层次和调度算法目标

### 1.处理机调度的层次

- 高级调度——作业调度
- 低级调度——进程调度
- 中级调度——内存调度

## 3.进程调度

1. 保存处理机现场信息
2. 按照算法选取进程
3. 把处理器分配给进程

## 4.实时调度

### 2.调度算法的分类

1. 非抢占式调度算法
2. 非抢占式优先调度算法
3. 基于时钟中断的抢占式优先级调度算法
4. 立即抢占的优先级调度算法

## 5.死锁描述

### 2.死锁起因

- 1.竞争不可抢占资源引起死锁
- 2.竞争可消耗资源引起死锁
- 3.进程推进顺序不当引起死锁

### 3.死锁定义，必要条件，处理方法

#### 1.死锁定义

> 如果一组进程的每一个进程都在等待仅由该组进程的其他进程所触发的时间，那么该组进程是死锁的（DeadLock）

#### 2.必要条件

1.**互斥条件**：  一段时间内，某资源只能被一个进程所占用

2.**请求和保持条件**： 进程至少保持一个资源，但是又提出了新的资源请求，而该资源被其他进程占用

3.**不可抢占条件**：进程已经获得的资源在释放前不可被抢占

4.**循环等待条件**：在死锁时，必须有条件循环链进行等待

#### 3.处理死锁

- 预防死锁
- 避免死锁
- 检测死锁
- 处理死锁

## 6.预防死锁

### 1.破坏“请求和保持条件”

> 一个进程请求资源，必须一次性申请所有资源
>
> 或者自己用完的资源就逐步释放

### 2.破坏不可抢占资源

> 当资源申请得不到满足的时候，必须释放持有的资源

### 3. 破坏 “循环条件”

> 对资源线性排序，并且赋予不同的序号

## 7.避免死锁

> 安全模式：不会有死锁
>
> 非安全模式：可能会有死锁

## 8.死锁检测和解除

### 1.检测

> 资源分配图（看是否有环）

### 2.死锁解除

- 1.抢占资源
- 2.终止进程



# 四、存储器管理

## 1.存储器层次结构

1. CPU寄存器
2. 高速缓存
3. 主存储器
4. 磁盘缓存
5. 固定磁盘
6. 可移动存储媒介

> 1是寄存器，2，3，4是主存，5，6是辅存

## 2.程序的装入与连接

> 用户程序需要在系统运行，必须先调入内存你，让编程一个可执行的程序，必须有以下几个步骤

1. 编译：由编译程序进行编译，形成若干个目标模块
2. 链接：由链接程序将编译好的一组目标模块和库函数进行链接，形成装入模块
3. 装入：由装入程序将装入模块进行装入

### 1. 程序的装入

#### 1.绝对装入方式

> 计算机系统很小，且仅能运行单道程序，知道程序驻留在内存的什么地方

#### 2.可重定位装入方式

> 在多道处理程序中，不可能预知编译后的目标模块放在内存的何处,起始地址为0，需要通过起始地址计算其他地址

#### 3.动态运行的装入方式

> 可重定位装入方式不允许程序运行时候在内存移动

### 2.程序的链接

#### 1.静态链接方式

> 程序运行前，键各个目标模块和相对应的库函数链接成一个装入模块，以后不再拆开

#### 2.装入时动态链接

> **边装入边链接的方式**，装入一个目标模块，若产生外部模块的调用，就将引用程序

**优点**:

1. 便于更新和修改
2. 便于实现对目标模块的共享

#### 3.运行时动态链接

> 原因：程序运行，需要装入模块不同，由于判断不了需要装入的是哪些模块，所以只能把所有可能的模块全部装入，这样效率低效

> 运行原理：执行过程，发现被调用模块未装入内存，就到OS找这个模块然后进行内存的装入

## 3.连续分配存储管理



### 1.单一连续分配

> 单道程序环境，仅装有一道用户程序，整个内存被程序独占

### 2.固定分区分配

#### 1.划定分区

1. 分区大小相等：缺乏灵活性
2. 分区大小不等：增加存储器分配的灵活性

#### 2.内存分配

> ​	给分区大小进行排队并且建立一张分区使用表

### 3.动态分区分配

**1.分配内存**：

请求分区大小u.size

每个分区大小m.size

m.size-u.size<=size(多余部分太小，不再切割)

**2.回收内存**

![image-20220826104205662](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220826104205662.png)

#### 4.动态分区分配算法

1. 首次适应（FF）算法
2. 循环首次适应（next fit,NF）
3. 最佳适应算法（BF）
4. 最坏适应算法（WF）

### 6.动态可重定位分区分配（时间换空间）

#### 1.紧凑

![image-20220826104542148](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220826104542148.png)



#### 2.动态重定位

> 计算公式： 访问内存地址 = 相对地址+重定位寄存器地址

> 该过程用了紧凑，若若干程序的内存移到某一处，只需要把新的内存起始地址替换原有内存起始地址即可

## 4.对换

1.选择被换出进程

> 1.首先选出处于阻塞或睡眠的进程
>
> 2.选用优先级最低的进程

2.进程换出过程

> 找出非共享的数据段和程序，如果对于共享的程序，数据段，有进程访问就不能换出

3.进程换入过程

> 找出PCB中 "就绪状态"但已经换出的进程，然后选已经换出磁盘时间最久的进程作为换入进程，为它申请内存，腾出足够内存空间



## 5分页存储管理

![image-20220827092112226](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220827092112226.png)

> **注意：页表中分配的页必须是连续的，页号现在是隐式的，页表项不用存页号，只需要存对应物理块号就可以了**，可能因为操作系统不能分配那么多连续的空间来存放页表所以就产生了二级页表，这些页也就成离散的了
>
> 页内偏移量 = 块内偏移量
>
> 页表项占用长度 = 有多少个块
>
> 块内偏移量+有多少块 =  块占用多少地址总线

## 6. 分段存储管理方式

### 1.引入分段存储管理

1. 方便编程
2. 信息共享
3. 信息保护

### 2.段页存储管理方式

![image-20220827103608959](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220827103608959.png)

**流程**

1. 先去段表查看段表大小和段号是否越界，没有越界就找到段内页号
2. 通过段内页号找到页表中的对应物理块号
3. 将物理块号和页内地址进行拼接形成物理地址，然后去找物理地址

> 获取指令和数据，需要访问三次内存，因此在地址变换机构需要增加一个高速缓冲寄存器

# 五、虚拟存储器

## 1.概述

### 2.定义和特征

#### 1.定义

> 用户看到自己的程序能够在系统中正常运行，他会认为系统的内存容量比自己的程序大，这种是一种错觉，是虚的，人们把这样的存储器称为虚拟存储器

> 虚拟存储器 有  **请求调入和置换功能**，逻辑容量 是内存+外存容量决定，运行速度接近内存速度，成本接近于外存

#### 2.特征

1. 多次性——允许程序和数据分成多次调入内存，和传统存储器的一次不同
2. 对换性——无需让作业一直常驻内存，作业可以换进换出
3. 虚拟性——能从逻辑上扩充内存容量，使用户看到内存容量大于实际容量

### 3.实现方法

**1）请求分页系统**

> 1.请求分页的页表机制——作为请求分页的数据结构
>
> 2.缺页中断机制——当用户要访问的页面为调入程序，就发生缺页中断,OS将缺少的页调入内存
>
> 3.地址变换机制：从分页地址变换机制演变过来

2）**请求分段系统**

> 1.请求分页的段表机制——作为请求分段的数据结构
>
> 2.缺页中断机制——当用户要访问的页面为调入程序，就发生缺页中断,OS将缺少的页调入内存
>
> 3.地址变换机制：从分页地址变换机制演变过来

## 2.请求分页存储管理

| 页号 | 物理块号 | 状态位P | 访问字段a | 修改位M | 外存地址 |
| ---- | -------- | ------- | --------- | ------- | -------- |

![image-20220905160437321](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220905160437321.png)



### 2.请求分页内存分配

> 最小物理块数是能保证进程正常运行所需的最小物理块

**2.内存分配策略**

1.固定分配局部置换

> 固定分配一组物理块，运行期间不改变，局部置换：发现缺页，选一页换出然后选一页换入

2.可变分配全局置换

> - 分配是调整的
> - 置换是选择全局物理块置换的

3.可变分配局部置换

> - 分配是可调整的
> - 置换是选择内存的某页进行置换的

## 3. 页面置换算法

1. 最佳置换算法
2. 先进先出算法
3. 最近最久未使用算法（LRU）
4. 最少使用置换算法（LFU）
5. Clock置换算法

> Clock 置换算法

![image-20220905163921153](https://secondlife.oss-cn-qingdao.aliyuncs.com/img/image-20220905163921153.png)

## 5.请求分段存储管理

### 1.硬件支持

| 段名 | 段长 | 段基址 | 存储方式 | 访问字段a | 修改位m | 存在位p | 增补位 | 外存地址 |
| ---- | ---- | ------ | -------- | --------- | ------- | ------- | ------ | -------- |



# 六、磁盘管理

## 8.磁盘调度算法

#### 1.先来先服务(FCFS)

#### 2.最短寻道时间优先（SSTF）

#### 3.扫描（SCAN）算法

#### 4.循环扫描（CSCAN）算法





































