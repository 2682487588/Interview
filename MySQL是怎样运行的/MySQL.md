##  1.  MySQL中myisam与innodb的区别?

* InnoDB支持事物，而MyISAM不支持事物
* InnoDB支持行级锁，而MyISAM支持表级锁
* InnoDB支持MVCC, 而MyISAM不支持
* InnoDB支持外键，而MyISAM不支持
* InnoDB不支持全文索引，而MyISAM支持。

`MVCC`，全称`Multi-Version Concurrency Control`，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

## 2. 事务的特性

- 原子性：是指事务包含所有操作要么全部成功，要么全部失败回滚。
- 一致性：指事务必须使数据库从一个一致性状态变换成另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
  拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。
- 隔离性：是当多个用户并发访问数据库时，比如操作同一张表时，数据表为每个用户开启的事务，**不能被其他事务所干扰，多个并发事务之间要相互隔离**。
- 持久性**：持久性是指一个事务一旦被提交，那么对数据库中的数据的改变就是永久的**，即便是在数据库系统遇到故障的性况下也不会丢失提交事务的操作。

## 3. 并发操作问题

- 脏读：脏读是指在**一个事务处理过程中读取到了另外一个未提交事务中的数据**。(查)
- 不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内**多次查询却返回了不同的数据值**，这是由于在查询间隔，被另一个事务修改并提交了。（查改查）
- 虚读(幻读)：幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。（读到了另外一个事务的数据）
  比如两个事务操作，A 事务查询状态为 1 的记录时，这时 B 事务插入了一条状态为 1 的记录，A 事务再次查询返回的结果不一样。

## 4. 事务的隔离级别

- Serializable(串行化)：可避免脏读、不可重复读、幻读。（就是串行化读数据）
- Repeatable read(可重复读)：可避免脏读、不可重复读的发生。
- Read committed(读已提交)：可避免脏读的发生。
- Read uncommitted(读未提交)：最低级别，任何情况都无法保证。

在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。##

## 5. 索引是什么？

索引是表的目录，在查找内容之前可以先在目录中查找索引位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。

索引是帮助MySQL高效获取数据的数据结构。

## 6. 索引能干什么?有什么好处？

当表中的数据量越来越大时，索引对于性能的影响愈发重要。索引能够轻易将查询性能提高好几个数量级，总的来说就是可以明显的提高查询效率。

## 7.  索引的种类有哪些？

1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，

2、从应用层次来分：普通索引，唯一索引，复合索引

3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。

平时讲的索引类型一般是指在应用层次的划分。

* 普通索引：即一个索引**只包含单个**列，一个表可以有多个单列索引 
* 复合索引**：多列值组成一个索引**，专门用于**组合搜索**，其效率大于索引合并 
* 唯一索引：**索引列的值必须唯一，但允许有空值**

## 8. 为什么 MySQL 的索引要使用 B+树而不是其它树形结构?比如 B 树？

B-tree：因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；

Hash：虽然可以快速定位，但是没有顺序，IO复杂度高。

二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。

红黑树：树的高度随着数据量增加而增加，IO代价高。

**不使用平衡二叉树的原因如下**：

最大原因：深度太大(因为一个节点最多只有2个子节点)，一次查询需要的I/O复杂度为O(lgN),而b+tree只需要O(log_mN),而其出度m非常大，其深度一般不会超过4 
平衡二叉树逻辑上很近的父子节点，物理上可能很远，无法充分发挥磁盘顺序读和预读的高效特性。

## 9. MyISAM和InnoDB实现BTree索引方式的区别

### MyISAM

B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。 
索引文件和数据文件是分离的

### InnoDB

- InnoDB 的 B+Tree 索引分为主索引（聚集索引）和辅助索引(非聚集索引)。一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树。
- 辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。
- 就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

## 10. 什么是最左匹配原则？

最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。 
例如：b = 2 如果建立(a,b)顺序的索引，是匹配不到(a,b)索引的；但是如果查询条件是a = 1 and b = 2,就可以，因为**优化器会自动调整a,b的顺序**。再比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。

**最左匹配原则的原理**

MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引.最左匹配原则都是针对联合索引来说的

- 我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。 
  例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。

同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a>1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。

优点：最左前缀原则的利用也可以显著提高查询效率，是常见的MySQL性能优化手段。

## 11. 哪些列上适合创建索引？创建索引有哪些开销？

经常需要作为条件查询的列上适合创建索引，并且该列上也必须有一定的区分度。

创建索引需要维护，在插入数据的时候会重新维护各个索引树（数据页的分裂与合并），对性能造成影响

## 12. 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？

1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

## 13. **MySQL建表的约束条件有哪些**？

- 主键约束（Primay Key Coustraint） 唯一性，非空性
- 唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个
- 检查约束 (Check Counstraint) 对该列数据的范围、格式的限制
- 默认约束 (Default Counstraint) 该数据的默认值
- 外键约束 (Foreign Key Counstraint) 需要建立两表间的关系并引用主表的列

## 14. MySQL执行查询的过程？

1. 客户端通过TCP连接发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配
2. 查缓存。（当判断缓存是否命中时，MySQL不会进行解析查询语句，而是直接使用SQL语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）
3. 语法分析（SQL语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。
4. 优化。是否使用索引，生成执行计划。
5. 交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。

![](http://blog-img.coolsen.cn/img/image-20210220120155334.png)

## 15. MySQL的binlog有几种录入格式?分别有什么区别?

有三种格式,statement,row和mixed.

- statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.
- row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大。
- mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row. 此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.



## 16.Explain执行

| Column        | 含义                     |
| ------------- | ------------------------ |
| id            | 查询序号                 |
| select_type   | 查询类型(本次的查询类型) |
| table         | 表名                     |
| partitions    | 匹配分区                 |
| type          | join类型                 |
| possible_keys | 可能的索引               |
| key           | 实际上使用的索引         |
| key_len       | 索引长度                 |
| ref           | 和索引比较的列           |
| rows          | 要检索的行数(估算的值)   |
| filtered      | 查询条件过滤百分比       |
| Extra         | 额外信息                 |

### 1.id

> id列数字越大，越先进行，如果数字一样大，就从上到下运行

### 2.select_type

| select_type          | 类型说明                                             |
| -------------------- | ---------------------------------------------------- |
| SIMPLE               | 简单SELECT(不使用UNION或子查询)                      |
| PRIMARY              | 最外层的SELECT                                       |
| UNION                | UNION中第二个或之后的SELECT语句                      |
| DEPENDENT UNION      | UNION中第二个或之后的SELECT语句取决于外面的查询      |
| UNION RESULT         | UNION的结果                                          |
| SUBQUERY             | 子查询中的第一个SELECT                               |
| DEPENDENT SUBQUERY   | 子查询中的第一个SELECT, 取决于外面的查询             |
| DERIVED              | 衍生表(FROM子句中的子查询)                           |
| MATERIALIZED         | 物化子查询                                           |
| UNCACHEABLE SUBQUERY | 结果集无法缓存的子查询，必须重新评估外部查询的每一行 |
| UNCACHEABLE UNION    | UNION中第二个或之后的SELECT，属于无法缓存的子查询    |

### 3.table

> 查询的表名不一定是实际存在的表明, （可以为如下情况）

- <union M, N>   :引用id为M和N  Union之后的值
- 引用id为N的派生表。派生表可以是一个结果集
- 引用id为N子查询之后的表，生成一个临时表保存子查询

### 4.type (重要)

> 从上到下效率依次递减

| 序号 | 类型            | 描述                                            |
| ---- | --------------- | ----------------------------------------------- |
| 1    | system          | 表中只有一行数据或者是空表，                    |
| 2    | const           | 只有一行记录                                    |
| 3    | eq_ref          | 多表join,对于前面表的每一行，当前表只能找到一行 |
| 4    | ref             | 对于前表的每一行，此表索引可以匹配到多行        |
| 5    | fulltext        | 使用全文索引                                    |
| 6    | ref_or_null     | 和ref类似，只不过加了null值比较                 |
| 7    | index_merge     | 使用了两个以上的索引，最后取交集或者并集        |
| 8    | unique_subquery | where中in形式子查询，子查询返回不重复唯一值     |
| 9    | index_subquery  | 类似unique_subquery,适用于非唯一索引            |
| 10   | range           | 索引范围查询 =,<>,>=,BETWEEN这些                |
| 11   | index           | 索引全表扫描                                    |
| 12   | ALL             | 全表扫描性能最差                                |

### 5.partitions

> 5.7之后默认为null

### 6.possible_keys

> 查询的索引可能列出来

### 7.key

> 真正用到的索引

### 8.key_len

> 查询用到的索引长度

> key_len 只计算 `where`条件用到的索引长度，排序和分组用到了索引也不会计算上

### 9.ref

> - 等值查询为const
> - 链接查询为关联字段
> - 表达式为func

### 10.rows(重要)

> mysql估计的扫描的行数

### 11.filtered

> 存储引擎在server层过滤之后，剩下多少满足记录数量的比例

### 12.extra(重要)

- **distinct**：在select部分使用了distinct关键字
- **Using filesort**：当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, **都建议优化去掉, 因为这样的查询 CPU 资源消耗大.**
- **Using index**
  “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明**性能不错**
- **Using temporary**
  查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.

## 17.展示索引

> SHOW INDEX FROM <tablename>;



## 18.MySQL[数据]()库cpu飙升的话，要怎么处理呢？ 

 排查过程： 

 1、 使用top 命令观察，确定是MySQLd导致还是其他原因。 

 2、 如果是MySQLd导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。 

 3、 找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，[数据]()量是否太大。 

 处理： 

 1、 kill 掉这些线程(同时观察 cpu 使用率是否下降)， 

 2、 进行相应的调整(比如说加索引、改 sql、改内存参数) 

 3、 重新跑这些 SQL。 

 其他情况： 

 也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等

## 19.索引优化

1、 Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉[最大数]()量记录的条件必须写在Where子句的末尾.HAVING最后。 

 2、 用EXISTS替代IN、用NOT EXISTS替代NOT IN。 

 3、 避免在索引列上使用计算 

 4、 避免在索引列上使用IS NULL和IS NOT NULL 

 5、 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 

 6、 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 

 7、 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描

## 20.Hash索引和B+树索引的底层实现原理

Hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树，对于每一次的查询都是从根节点出发，查找到叶子节点方可获得所查键值，然后根据查询判断是否需要回表查询数据。

Hash索引和B+树索引区别如下：

- 一般情况下，Hash索引进行**等值查询更快**，但**无法进行范围查询**。
  - 　　　因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的所有节点皆遵循左节点小于父节点，右节点大于父节点，多叉树也类似，天然支持范围查询。
- Hash索引不支持使用索引进行排序。
- Hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理是因为hash函数的不可预测性。AAAA和AAAAB的索引没有相关性。
- Hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件（聚簇索引，覆盖索引等）时可以值通过索引完成查询。
- Hash索引虽然在等值查询上比较快，但不稳定，性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

大多情况下，直接选择B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引

## 21怎么才可以知道这条语句运行很慢的原因？

> 对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种[数据]()库，或者是哪种[数据]()库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。 **而执行计划，就是显示[数据]()库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息**





- 18
- 20
- 21
- 26
- 
