### 1.面向过程和面向对象

面向过程：**性能比面向对象高**，没有面向对象容易**维护、复用、拓展**

面向对象：**性能比面向过程低**，易于**维护，复用，拓展**

**ps:**面向过程也需要分配内存，Java性能差的原因是Java是半编译语言，最终的执行代码并不是可以直接被CPU使用的**二进制机械码**

### 2.Java特点

- 简单易学
- **面向对象**
- **平台无关性**
- 可靠性
- 安全性
- 支持多线程(C++没有多线程，需要调用操作系统的多线程设计)
- **支持网络编程**
- **编译和解释并存**

### 3.JVM 、JDK 、JRE

#### JVM

运行Java字节码的虚拟机

#### 字节码

**JVM可以理解的代码**就是字节码（即扩展名为.class的文件），**只面向虚拟机**，解决传统语言效率低，保留编程可移植

![Java程序运行过程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png)

ps：.class这一步会比较慢，因为是解释器**边解释边执行**

#### 总结：

JVM是**运行字节码的虚拟机**，JVM针对不同系统特定实现，目的是使用相同的字节码，都会返回相同的结果

#### JDK，JRE

JDK（**Java Development Kit**（成套工具））,功能齐全的Java SDK，有JRE的一切，还有编辑器(javac)和工具(javadoc)

JRE是**Java运行时环境**，包括JVM，JAVA类库

### 5.Java和C++区别?

- 都是**面向对象的语言**，支持**封装、继承、多态**
- Java不提供指针访问内存，更安全
- **Java单继承，C++支持多重继承**
- Java有**自动内存管理机制，可以自动释放内存**

### 8.字符型常量和字符串常量

1.**形式上**：字符单引号'',字符串双引号""

2.**含义上:**字符常量相当于一个**整型值(ASCII值)**,字符串常量代表一个**地址值(字符串在地址里面的位置** )

3.**内存大小**：字符：两字节，字符串：若干字节

![img](http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg)

### 9.构造器Constructor可否被override

父类**私有属性**和**构造方法**不可被**继承**，所以Constructor**不可被重写**，但是可以**overload**

### 10.重载和重写的区别

- **重载**：发生在**同一个类**，**方法名必须相同**，**参数类型**不同，个数不同，**顺序**不同，**返回值，修饰符**可以不同
- **重写**：**父子类中**，**方法名，参数列表相同**
  - **返回值**范围**小于等于**父类
  - **异常**范围**小于等于**父类
  - **访问修饰符大于等于**父类

### 11.三大特性：继承、封装、多态

#### 封装：

封装把一个**对象私有化**，同时提供一下**外界可以访问属性的方法**

#### 继承:

继承是使用**已存在的类的定义**作为基础建立新类的技术，新类可以添**加新的数据或新的功能**，也可以**用父类的功能**，继承方便我们**复用代码**

##### ps:

1.子类**拥有**父类所有的属性和方法（包含私有方法和私有属性），但是父类的这些子类无法访问，**只是拥有**

2.子类可以有自己的属性和方法

3.子类可以以自己的方式实现父类

#### 多态：

所谓多态就是指**程序中定义的引用变量**所指**向的具体类型**和**通过该引用变量发出的方法**调用在**编程时并不确定**

引用变量引出的方法到底是哪个类实现的方法，必须**程序运行期间决定**

实现多态：

- 继承(多个子类对一个方法重写)
- 接口（实现接口并覆盖接口中的同一个方法）

### 12.String StringBuffer StringBuilder

#### String

**String用final修饰，是不可变的**

StringBuffer和Builder继承与AbstractStringBuilder类 **没有被final修饰**

#### 线程安全性

- String常量--线程安全
- StringBuffer-加了同步锁-线程安全
- StringBuilder- 未加同步锁-线程不安全

#### 性能

- String每次都会生成一个String对象
- StringBuffer每次会对对象本身进行操作
- StringBuilder对比StringBuffer只有10-15%性能，还要冒着多线程不安全风险

#### 总结：

1.少量数据：String

2.单线程大量:StringBuilder

3.多线程大量:StringBuffer

### 13.自动装箱和拆箱

- **装箱**：将**基本类型**用他们对应的**引用类型**包装
- **拆箱**：将**包装类型**转换为**基本数据类型**

### 14.在一个静态方法内调用一个非静态成员为什么是违法的

**静态方法不通过对象调用**，所以静态方法不能调用非静态变量

### 15. 在 Java 中定义一个不做事且没有参数的构造方法的作用

Java在执行子类构造方法前，如果没有用**super()调用父类特定构造方法**，则会调用**父类"无参构造"**，如果只有有参构造，则没有super调用的无参构造，**编译会出错**

### 16.Import java 和javax

原来导入的是Java包，后来javax成为JavaAPI一部分，所以，实际上没有区别

### 17.接口和抽象类区别

1.接口默认public,不能有实现(Java8可以)，抽象类可以有非抽象方法

2.接口只能有static,final变量，抽象类不一定

3.一个类可以**实现多个接口**，只能**实现一个抽象类**，接口extends**拓展多个接口**

### 18.成员变量和局部变量

#### 语法形式：

成员变量：属于类，可以被public,private,static修饰

局部变量: 方法定义的变量或者方法的参数，不能被**访问修饰符**和**static**修饰

都可以被final修饰

#### 内存存储

static修饰成员变量**属于类**，不修饰是属于**实例**，对象存在于**堆内存**，局部变量存在于**栈内存**

#### 内存的生存空间：

成员变量随**对象创建存在**，局部变量随方法**调用消失**

#### 赋值：

**成员变量**如果**没有赋值会自动赋值**，局部不会

### 19. 创建一个对象用运算符

new进行创建，**对象**在**堆内存**，**对象实例**在**栈内存**

### 20.方法返回值

值得是我们获取方法体代码执行后产生的结果，作用：接收结果，便于其他操作

### 21.类的构造方法的作用

一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

完成对类对象的初始化，可以执行，会自动调无参构造

### 22.构造方法特性

- 方法名和类名相同
- 没有参数但不能用void
- 无需调用，生成类对象自动执行

### 23.静态方法和实例方法

1.调用静态方法，可以用**类名.方法名**,也可以**对象名.方法名**,**实例方法只有后者**,调用静态方法无需创建对象

2.静态方法**访问本类成员**，只访问(**静态成员变量**和**静态方法**)，实例方法无限制

### 24.对象和对象引用的相等

对象的相等——内存**存放内容**是否相等

引用相等——**内存地址是否相等**

### 23.调用父类无参构造

帮子类做初始化

### 26.==和equals

#### ==对于引用类型和基本类型作用不同

- 对于**基本类型**，==比较的是值
- 对于引用数据类型，==比较的是**对象的内存地址**

>  Java只有值传递，所以==本质还是比较值，因为引用变量存的是对象地址

equals()不能直接用于**基本数据**判断，只能作为对象的判断

- **类没有覆盖 `equals()`方法** ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象
- **类覆盖了 `equals()`方法** ：一般我们都覆盖 `equals()`方法来比较两个对象中的属性是否相等

### 27 hashCode() 与 equals()



### 泛型

泛型是JDK5引入的一个**新特性**，泛型提供**安全监测机制**，允许程序员在**编译时检测非法类型**

#### 类型擦除

Java泛型是**伪泛型**，因为泛型在**运行期间都会被擦除掉**，这就是类型擦除

~~~java
List<Integer> list = new ArrayList<>();

list.add(12);
//这里直接添加会报错
list.add("a");
Class<? extends List> clazz = list.getClass();
Method add = clazz.getDeclaredMethod("add", Object.class);
//但是通过反射添加是可以的
//这就说明在运行期间所有的泛型信息都会被擦掉
add.invoke(list, "kl");
System.out.println(list);

~~~



