### 字符串类型

​		1.int 编码：保存的是可以用 long 类型表示的整数值。

　　2、raw 编码：保存长度大于44字节的字符串

　　3、embstr 编码：保存长度小于44字节的字符串

embstr和raw都是用redisObject和sds保存数据,区别在于,embstr的使用只分配一次内存空间,raw需要分配两次内存空间，

好处：少分配一次

坏处：修改的时候需要重新分配内存，所以embstr只表现为已读 

#### 编码转换

int存的不是整数或者超过long的范围会转成raw

### 列表类型

- ziplist(压缩列表) 
-  linkedlist(双端链表)

满足列表元素小于512个，每个元素长度小于64字节，用ziplist编码，否则用linkedlist编码

### 哈希对象

-  ziplist 
-  hashtable

ziplist，profile 存储如下：

![img](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530122525661-752750675.png)

**hashtable 编码时**，哈希表对象底层使用字典数据结构，哈希对象中的每个键值对都使用一个字典键值对，上面命令存储如下

![img](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530122608271-980707096.png)

**编码转换**

　　和上面列表对象使用 ziplist 编码一样，当同时满足下面两个条件时，使用ziplist（压缩列表）编码：

　　1、列表保存元素个数小于512个

　　2、每个元素长度小于64字节

　　不能满足这两个条件的时候使用 hashtable 编码。第一个条件可以通过配置文件中的 set-max-intset-entries 进行修改

### 集合对象（set）

- intset
-  hashtable

intset 编码的集合对象使**用整数集合作为底层实现**，集合对象包含的所有元素都被保存在整数集合中

hashtable 编码的**集合对象使用 字典作为底层实现**，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字典的值则全部设置为 null。这里可以类比Java集合中HashSet 集合的实现，HashSet 集合是由 HashMap 来实现的，集合中的元素就是 HashMap 的key，而 HashMap 的值都设为 null。

**②、编码转换**

　　当集合同时满足以下两个条件时，使用 intset 编码：

　　1、集合对象中所有元素都是**整数**

　　2、集合对象所有元素数量不超过**512**

　　不能满足这两个条件的就使用 hashtable 编码。第二个条件可以通过配置文件的 set-max-intset-entries 进行配置。

### 有序集合对象

-  ziplist

- skiplist

ziplist 编码的**有序集合对象**使用**压缩列表作为底层实现**，每**个集合元素使用两个紧挨在一起的压缩列表节点来保存**，第一个节点**保存元素的成员**，第二个节点**保存元素的分值**。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置。

![img](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530211037364-539249809.png)

![img](https://images2018.cnblogs.com/blog/1120165/201805/1120165-20180530210919276-1209186625.png)

skiplist 编码的有序集合对象使用 zet 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳跃表：

```
typedef` `struct` `zset{
``   ``//跳跃表``   ``zskiplist *zsl;`` 
``//字典``   ``dict *dice;``
}
zset;
```

　　**字典的键保存元素的值**，**字典的值则保存元素的分值**；跳跃表节点的 **object 属性保存元素的成员**，跳跃表节点的 score 属性保存元素的分值。

ziplist 编码：

　　1、保存的元素数量小于128；

　　2、保存的所有元素长度都小于64字节。